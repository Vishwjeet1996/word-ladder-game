<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Word Ladder Game - Levels</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Use Inter and Space Mono for a clean, modern, and code-like look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom font for words to give it a game feel */
        .font-mono-game {
            font-family: 'Space Mono', monospace;
        }
    </style>
</head>
<body class="bg-gray-900">

<div id="root">
    </div>

<script type="text/babel">
    const { useState, useCallback, useEffect, useMemo, useRef } = window.React; 
    const ReactDOM = window.ReactDOM;

    // --- ICON Definitions ---
    const Icons = {
		RefreshCw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4"/></svg>,        CheckCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="M9 11l3 3L22 4"/></svg>,
        XCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6"/><path d="M9 9l6 6"/></svg>,
        ChevronRight: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
        Hash: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>,
        BookOpen: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
        Loader: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a10 10 0 1 0 5.4 18.5"/><path d="M12 2v2"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M17.4 6.6l-1.4 1.4"/><path d="M6.6 17.4l-1.4 1.4"/></svg>,
        Zap: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
		Trophy: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 13c0 2.038-2.239 4.5-5 4.5S7 15.038 7 13c0 1.444 10 1.444 10 0Z"/><path fill="currentColor" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/></svg>,        LogOut: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
		RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 9h13a5 5 0 0 1 0 10H7M3 9l4-4M3 9l4 4"/></svg>,        HelpCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>,
		Settings: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="square" strokeLinejoin="round" strokeWidth="2" d="M10 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h2m10 1a3 3 0 0 1-3 3m3-3a3 3 0 0 0-3-3m3 3h1m-4 3a3 3 0 0 1-3-3m3 3v1m-3-4a3 3 0 0 1 3-3m-3 3h-1m4-3v-1m-2.121 1.879-.707-.707m5.656 5.656-.707-.707m-4.242 0-.707.707m5.656-5.656-.707.707M12 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/></svg>,
		};

    // --- LEVEL CONFIGURATION ---
    const LEVELS = {
        EASY: { 
            name: '3-Letter Warmup', 
            description: 'Quick puzzles with small words.',
            length: 3, 
            pairs: [
                { start: 'cat', target: 'dog' },
                { start: 'pig', target: 'pen' },
                { start: 'sun', target: 'day' },
                { start: 'run', target: 'kid' },
                { start: 'try', target: 'buy' },
                { start: 'top', target: 'can' },
                { start: 'why', target: 'how' },
                { start: 'low', target: 'new' },
                { start: 'fix', target: 'met' },
                { start: 'red', target: 'dad' }
            ]
        },
        MEDIUM: { 
            name: '4-Letter Standard', 
            description: 'The classic Word Chain experience.',
            length: 4, 
            pairs: [
                { start: 'cool', target: 'book' },
                { start: 'word', target: 'game' },
                { start: 'make', target: 'lake' },
                { start: 'slow', target: 'fast' },
                { start: 'lead', target: 'gold' },
                { start: 'home', target: 'cave' },
                { start: 'ship', target: 'boat' },
                { start: 'four', target: 'five' },
                { start: 'mind', target: 'move' },
                { start: 'fall', target: 'rise' }
            ]
        },
        HARD: { 
            name: '5-Letter Challenge', 
            description: 'Longer words requiring careful thought.',
            length: 5, 
            pairs: [
                { start: 'drive', target: 'dream' },
                { start: 'plane', target: 'glass' },
                { start: 'crane', target: 'stack' },
                { start: 'light', target: 'heavy' },
                { start: 'wheat', target: 'bread' },
                { start: 'smart', target: 'dummy' },
                { start: 'solve', target: 'proof' },
                { start: 'stone', target: 'money' },
                { start: 'train', target: 'wheel' },
                { start: 'heart', target: 'break' }
            ]
        }
    };

    // --- BASIC HARDCODED PROFANITY LIST for demonstration ---
    // Used only if allowCurseWords is false. This list is illustrative, not exhaustive.
    const PROFANITY_LIST = [
        'shit', 'fuck', 'ass', 'bitch', 'cunt', 'piss', 'nigga', 'boob',
        'wank', 'dick', 'crap', 'pube', 'slut', 'tits', 'cock', 'boobs'
    ];

    // Dictionary API for word validation
    const API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
    const MAX_RETRIES = 3;
	
	// Whitelist for common, short words that the live API might occasionally fail to find.
    const LOCAL_WORD_WHITELIST = [
        'look', 'good', 'door', 'fish', 'four', 'five', 'tree', 'zero', 'jump', 'move', 'hold', 'send'
    ];

    /**
     * Checks word validity using the Dictionary API and an internal profanity filter.
     * @param {string} word - The word to check.
     * @param {boolean} allowCurseWords - If true, profanity check is skipped.
     * @param {number} retries - Internal retry counter for API.
     */
    const checkWordValidity = async (word, allowCurseWords, retries = 0) => {
        const cleanedWord = word.trim().toLowerCase();
        if (cleanedWord === '') return false;

        // --- PROFANITY CHECK ---
        if (!allowCurseWords) {
            if (PROFANITY_LIST.includes(cleanedWord)) {
                return false; // Invalidated due to profanity
            }
        }
        // --- END PROFANITY CHECK ---
		
        // NEW LOCAL CHECK: Bypass API if word is in the local whitelist
        if (LOCAL_WORD_WHITELIST.includes(cleanedWord)) {
            return true;
        }
        const url = `${API_URL}${cleanedWord}`;
        
        try {
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                // API returns an array of definitions if valid, or a JSON object with a title 'No Definitions Found' if invalid
                return Array.isArray(data);
            } else if (response.status === 404) {
                return false;
            } else {
                throw new Error(`API returned status ${response.status}`);
            }
        } catch (error) {
            if (retries < MAX_RETRIES) {
                const delay = Math.pow(2, retries) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
                // Must pass allowCurseWords on retry
                return checkWordValidity(word, allowCurseWords, retries + 1); 
            }
            console.error(`Failed to check word validity for "${word}" after ${MAX_RETRIES} retries:`, error);
            // Default to invalid if API consistently fails
            return false; 
        }
    };

    /**
     * Checks if the current word is exactly one letter different from the previous word.
     */
    const isOneLetterDifference = (prevWord, currentWord) => {
        if (prevWord.length !== currentWord.length) return false;
        let diffCount = 0;
        for (let i = 0; i < prevWord.length; i++) {
            if (prevWord[i] !== currentWord[i]) {
                diffCount++;
            }
        }
        return diffCount === 1;
    };

    // --- HELP MODAL COMPONENT ---

    const HelpModal = ({ onClose }) => {
        const steps = [
            {
                title: "The Goal",
                text: "The objective is to change the starting word into the target word, one step at a time.",
            },
            {
                title: "The Rules (Crucial!)",
				text: "In each step (or link in the chain), you must create a new word by changing only one letter from the previous word. All words must be valid English words.",
				example: "Example: CAT â†’ COT (change 'A' to 'O') â†’ COG (change 'T' to 'G')."
				},
            {
                title: "How to Play a Turn",
                text: "1. Click on any letter in the current (bottom-most) word in your chain.\n2. The letter will highlight, indicating it's ready to change.\n3. Type the new single letter on your keyboard. The game will automatically check if the resulting word is one letter different AND if it's a valid word using a live dictionary API.\n4. If successful, the new word is added to your chain!",
            },
            {
                title: "Winning",
                text: "You win the game when you successfully create the **Target Word**. The fewest steps wins!",
            }
        ];

        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
                <div 
                    className="w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6 transform transition-all"
                    onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside the modal
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-3">
                        <h2 className="text-3xl font-extrabold text-purple-400 flex items-center">
                            <Icons.HelpCircle className="mr-3" size={30} /> How to Play
                        </h2>
                        <button onClick={onClose} className="p-2 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={28} />
                        </button>
                    </div>

                    <div className="space-y-6">
                        {steps.map((step, index) => (
                            <div key={index} className="p-4 bg-gray-700/50 rounded-lg border-l-4 border-purple-500 shadow-md">
                                <h3 className="text-xl font-bold text-gray-100 mb-2">{index + 1}. {step.title}</h3>
                                <p className="text-gray-300 whitespace-pre-wrap">{step.text}</p>
                                {step.example && (
                                    <p className="mt-2 p-2 bg-gray-800 rounded text-yellow-400 font-mono-game text-lg border border-yellow-500/50">
                                        {step.example}
                                    </p>
                                )}
                            </div>
                        ))}
                    </div>

                    <div className="pt-4 border-t border-gray-700">
                        <button
                            onClick={onClose}
                            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200"
                        >
                            Got It, Let's Play!
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- NEW: SETTINGS MODAL COMPONENT ---

    const SettingsModal = ({ onClose, allowCurseWords, setAllowCurseWords }) => {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
                <div 
                    className="w-full max-w-md max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6 transform transition-all"
                    onClick={(e) => e.stopPropagation()} // Prevent closing
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-3">
                        <h2 className="text-3xl font-extrabold text-purple-400 flex items-center">
                            <Icons.Settings className="mr-3" size={30} /> Game Settings
                        </h2>
                        <button onClick={onClose} className="p-2 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={28} />
                        </button>
                    </div>

                    <div className="space-y-4">
                        <div className="flex justify-between items-center p-4 bg-gray-700/50 rounded-lg border-l-4 border-blue-500 shadow-md">
                            <div>
                                <h3 className="text-xl font-bold text-gray-100">Allow Profanity</h3>
                                <p className="text-sm text-gray-300">Allow potentially offensive or sensitive words.</p>
                            </div>
                            {/* Toggle Switch */}
                            <button
                                onClick={() => setAllowCurseWords(prev => !prev)}
                                className={`relative inline-flex items-center h-8 w-14 rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 ${allowCurseWords ? 'bg-green-600' : 'bg-gray-600'}`}
                            >
                                <span className="sr-only">Toggle Profanity Filter</span>
                                <span
                                    className={`inline-block w-6 h-6 transform bg-white rounded-full transition-transform ${allowCurseWords ? 'translate-x-6' : 'translate-x-1'}`}
                                ></span>
                            </button>
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700">
                        <button
                            onClick={onClose}
                            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200"
                        >
                            Close Settings
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- WIN MODAL COMPONENT (NEW) ---

    const WinModal = ({ chain, steps, onNewGame, onReplay, startWord, targetWord }) => {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-80 backdrop-blur-sm">
                <div 
                    className="w-full max-w-4xl max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 space-y-6 transform transition-all border-4 border-green-500"
                >
                    <div className="text-center space-y-4">
                        <Icons.Trophy className="mx-auto text-yellow-400" size={60} />
                        <h2 className="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-teal-500">
                            CONGRATULATIONS!
                        </h2>
                        <p className="text-2xl font-semibold text-gray-200">
                            You solved the chain in <span className="text-yellow-400">{steps}</span> steps!
                        </p>
                    </div>

                    <div className="space-y-3">
                        <h3 className="text-xl font-bold text-gray-300 border-b border-gray-700 pb-2">Your Winning Chain:</h3>
                        {/* Horizontal display of the full word chain - ONLY SHOWN HERE */}
                        <div className="flex flex-wrap justify-center gap-2 max-h-[200px] overflow-y-auto p-2 border border-gray-700 rounded-lg bg-gray-900/50">
                            {chain.map((word, index) => (
                                <div 
                                    key={index}
                                    className={`px-4 py-2 rounded-lg font-mono-game text-xl font-bold uppercase transition-all duration-300 shadow-md
                                        ${word === startWord ? 'bg-purple-600 text-white' :
                                          word === targetWord ? 'bg-green-600 text-white' :
                                          'bg-gray-600 text-white'
                                        }`}
                                >
                                    {word}
                                    {/* Arrow separator (skip after the last word) */}
                                    {index < chain.length - 1 && (
                                        <span className="ml-2 text-gray-400">â†’</span>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700 flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        {/* New Game Button */}
                        <button
                            onClick={onNewGame}
                            className="flex-1 px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.BookOpen size={20} className="mr-2" /> New Game
                        </button>
                        
                        {/* Replay Button */}
                        <button
                            onClick={onReplay}
                            className="flex-1 px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.RefreshCw size={20} className="mr-2" /> Replay
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- MAIN APP COMPONENT ---

    const App = () => {
        const [startWord, setStartWord] = useState('');
        const [targetWord, setTargetWord] = useState('');
        const [wordLength, setWordLength] = useState(0);
        const [currentPath, setCurrentPath] = useState([]); // Array of words in the chain
        const [status, setStatus] = useState('MENU'); // MENU, PLAYING, WON, SETUP
        const [message, setMessage] = useState('');
        const [loading, setLoading] = useState(false);
        
        // EXISTING: State for Help Modal
        const [showHelp, setShowHelp] = useState(false); 
        
        // NEW: State for Settings
        const [showSettings, setShowSettings] = useState(false);
        const [allowCurseWords, setAllowCurseWords] = useState(false); // Default to disallow

        const [editingIndex, setEditingIndex] = useState(null); // Index of the letter being edited
        const [currentEditWord, setCurrentEditWord] = useState(''); // The word being typed/previewed before submission
        
        // Memoize the last word in the successful chain
        const lastWord = useMemo(() => currentPath[currentPath.length - 1], [currentPath]);

        // Update the word being edited whenever the last successful word changes
        useEffect(() => {
            setCurrentEditWord(lastWord || '');
        }, [lastWord]);

        const GAME_STATUS = {
            MENU: 'MENU',
            PLAYING: 'PLAYING',
            WON: 'WON',
            SETUP: 'SETUP' // Validation failed on Custom Level, remains on setup screen
        };

        const submitWord = useCallback(async (submittedWord) => {
            setMessage('');
            setLoading(true);

            // 1. Check for length/format (Should be handled by input controls, but as a safeguard)
            if (submittedWord.length !== wordLength) {
                setMessage(`Word must be exactly ${wordLength} letters long.`);
                setLoading(false);
                setCurrentEditWord(lastWord);
                return;
            }

            // Rule 2: Must be one letter different
            if (!isOneLetterDifference(lastWord, submittedWord)) {
                setMessage(`The new word "${submittedWord.toUpperCase()}" must differ by only one letter from "${lastWord.toUpperCase()}".`);
                setLoading(false);
                setCurrentEditWord(lastWord); // Revert back to the last valid word
                return;
            }
            
            // Rule 3: Cannot be an old word in the path
            if (currentPath.includes(submittedWord)) {
                setMessage(`"${submittedWord.toUpperCase()}" is already in your chain. Try a new word.`);
                setLoading(false);
                setCurrentEditWord(lastWord); // Revert back
                return;
            }
            
            // API Check (includes profanity check)
            setMessage(`Checking "${submittedWord.toUpperCase()}" in the live dictionary...`);
            // MODIFIED: Pass the allowCurseWords state
            const isValid = await checkWordValidity(submittedWord, allowCurseWords);
            setLoading(false);
            
            if (!isValid) {
                // Determine if the failure was due to dictionary or profanity (simple check)
                let failMessage = `"${submittedWord.toUpperCase()}" is not recognized as a valid word. Try again.`;
                if (!allowCurseWords && PROFANITY_LIST.includes(submittedWord)) {
                    // FIX: Changed specific profanity message to the generic one requested by the user
                    failMessage = `Profanity not allowed.`; 
                }
                setMessage(failMessage);
                setCurrentEditWord(lastWord); // Revert back
                return;
            }

            // Valid move
            const newPath = [...currentPath, submittedWord];
            setCurrentPath(newPath);
            
            if (submittedWord === targetWord) {
                setMessage(`ðŸŽ‰ CONGRATULATIONS! You solved the chain in ${newPath.length - 1} steps!`);
                setStatus(GAME_STATUS.WON);
            } else {
                setMessage('Excellent move! Keep going, one letter at a time.');
            }
            
        }, [lastWord, currentPath, targetWord, wordLength, allowCurseWords]); // ADDED allowCurseWords dependency


        /**
         * Unified game start/reset function for both predefined levels and Custom Levels.
         */
        const resetGame = useCallback(async (start, target, length, isCustom = false) => {
            const s = start.toLowerCase().trim();
            const t = target.toLowerCase().trim();
            
            setEditingIndex(null);
            setMessage('');

            // --- Word Length Validation ---
            if (s.length !== length || t.length !== length || s.length === 0) {
                const source = isCustom ? 'custom setup' : 'level configuration';
                setMessage(`[Validation Error from ${source.toUpperCase()}]: Both words must be exactly ${length} letters long.`);
                setStatus(isCustom ? GAME_STATUS.SETUP : GAME_STATUS.MENU);
                return;
            }

            // --- Custom Level Specific Checks ---
            if (isCustom) {
                if (s === t) {
                    setMessage(`[Validation Error]: The Start Word and Target Word cannot be the same. Please choose different words.`);
                    setStatus(GAME_STATUS.SETUP);
                    return;
                }
                if (!/^[a-z]+$/.test(s) || !/^[a-z]+$/.test(t)) {
                    setMessage(`[Validation Error]: Words must only contain lowercase English letters (a-z) and no spaces.`);
                    setStatus(GAME_STATUS.SETUP);
                    return;
                }
            }


            setWordLength(length);
            
            setLoading(true);
            setMessage('Validating words via API...');

            let isStartValid = true;
            let isTargetValid = true;

            // Only perform dictionary check if it's a Custom Level (predefined level words are assumed valid)
            if (isCustom) {
                [isStartValid, isTargetValid] = await Promise.all([
                    // MODIFIED: Pass allowCurseWords here
                    checkWordValidity(s, allowCurseWords),
                    checkWordValidity(t, allowCurseWords)
                ]);
            }
            
            setLoading(false);

            // --- Dictionary Validation Feedback (includes Profanity Check feedback) ---
            if (!isStartValid || !isTargetValid) {
                let errorMsg = `[Dictionary Error]: `;
                
                // Detailed check for profanity block on start/target words
                let isStartProfane = !allowCurseWords && PROFANITY_LIST.includes(s);
                let isTargetProfane = !allowCurseWords && PROFANITY_LIST.includes(t);

                if (isStartProfane || isTargetProfane) {
                    // FIX: Changed specific profanity message to the generic one requested by the user
                    errorMsg = `[Profanity Block]: Profanity not allowed.`; 
                } else {
                    // Fall back to dictionary error if not profane
                    if (!isStartValid && !isTargetValid) {
                        errorMsg += `Neither "${s.toUpperCase()}" nor "${t.toUpperCase()}" are valid words.`;
                    } else if (!isStartValid) {
                        errorMsg += `The Start Word "${s.toUpperCase()}" is not a valid English word.`;
                    } else {
                        errorMsg += `The Target Word "${t.toUpperCase()}" is not a valid English word.`;
                    }
                }
                
                setMessage(errorMsg);
                // Set status to SETUP so the user remains on the setup screen to correct words.
                setStatus(GAME_STATUS.SETUP); 
                return;
            }

            // Success
            setStartWord(s);
            setTargetWord(t);
            setCurrentPath([s]);
            setCurrentEditWord(s);
            setMessage(`Start your chain! Change a letter in ${s.toUpperCase()} by clicking it.`);
            setStatus(GAME_STATUS.PLAYING);
        }, [allowCurseWords]); // ADDED allowCurseWords dependency

        const startLevel = (levelKey) => {
            const level = LEVELS[levelKey];
            // Pick a random pair from the selected level
            const pair = level.pairs[Math.floor(Math.random() * level.pairs.length)];
            resetGame(pair.start, pair.target, level.length, false);
        };
        
        const quitGame = () => {
            setStartWord('');
            setTargetWord('');
            setWordLength(0);
            setCurrentPath([]);
            setMessage('');
            setEditingIndex(null);
            setCurrentEditWord('');
            setStatus(GAME_STATUS.MENU);
        };

        // --- NEW: Undo Last Move Function ---
        const undoLastMove = useCallback(() => {
            // Only allow undo if there's more than the starting word, game is playing, and not loading
            if (currentPath.length > 1 && status === GAME_STATUS.PLAYING && !loading) {
                const newPath = currentPath.slice(0, -1); // Removes the last element
                const newLastWord = newPath[newPath.length - 1];
                
                setCurrentPath(newPath);
                setCurrentEditWord(newLastWord);
                setEditingIndex(null); // Clear editing state
                setMessage(`Move undone. Current word is ${newLastWord.toUpperCase()}.`);
            }
        }, [currentPath, status, loading]);

        // --- Keyboard and Letter Click Logic ---

        const handleLetterClick = useCallback((index) => {
            if (status !== GAME_STATUS.PLAYING || loading) return;

            if (editingIndex === index) {
                // Clicking the already active letter cancels editing
                setEditingIndex(null);
                setMessage('');
                setCurrentEditWord(lastWord);
            } else {
                // Start editing a new letter
                setEditingIndex(index);
                setMessage(`Type the new letter for position ${index + 1}. Press ESC to cancel.`);
            }
        }, [status, loading, editingIndex, lastWord]);

        const handleKeyPress = useCallback((event) => {
            // Only process key presses if playing, not loading, and a letter is selected for editing
            if (status !== GAME_STATUS.PLAYING || loading || editingIndex === null) return;

            const key = event.key.toLowerCase();
            
            if (key.match(/^[a-z]$/) && key.length === 1) {
                event.preventDefault();

                const newWord = lastWord.split(''); // Start from the last *valid* word
                
                if (newWord[editingIndex] === key) {
                    setMessage('You must change the letter at the selected position.');
                    return;
                }
                
                newWord[editingIndex] = key;
                const potentialWord = newWord.join('');
                
                // Immediately update the visual preview of the word
                setCurrentEditWord(potentialWord);
                
                // Then submit the move (which handles validation, API check, and state update)
                submitWord(potentialWord);
                
                // Clear the editing focus right away
                setEditingIndex(null);

            } else if (key === 'escape') {
                // Escape key cancels editing
                setEditingIndex(null);
                setMessage('Editing canceled.');
                setCurrentEditWord(lastWord);
            }
        }, [status, loading, editingIndex, lastWord, submitWord]);

        useEffect(() => {
            // Set up and tear down the global keydown listener
            window.addEventListener('keydown', handleKeyPress);
            return () => {
                window.removeEventListener('keydown', handleKeyPress);
            };
        }, [handleKeyPress]);

        // --- UI COMPONENTS ---

        const MessageDisplay = () => {
            let currentMessage = message;
            let icon = null;
            let colorClass = 'bg-blue-600';
            let iconSize = 20;

            if (!currentMessage && !loading) return null;

            // Check for explicit error markers added in validation logic
            const isError = currentMessage.includes('[Validation Error]') || currentMessage.includes('[Dictionary Error]') || currentMessage.includes('[Profanity Block]') || currentMessage.includes('differ by only one') || currentMessage.includes('already in your chain');

            if (loading) {
                currentMessage = message || '...connecting to dictionary...';
                icon = <Icons.Loader size={iconSize} className="animate-spin" />;
                colorClass = 'bg-yellow-600';
            } else if (status === GAME_STATUS.WON) {
                icon = <Icons.Trophy size={iconSize} />;
                colorClass = 'bg-green-600';
            } else if (isError) {
                icon = <Icons.XCircle size={iconSize} />;
                colorClass = 'bg-red-600';
            } else if (status === GAME_STATUS.PLAYING) {
                // If message is just a standard one, use blue
                icon = <Icons.CheckCircle size={iconSize} />;
                colorClass = 'bg-blue-600';
            }


            return (
                <div className={`p-4 rounded-xl shadow-2xl text-white font-semibold flex items-center space-x-3 ${colorClass}`}>
                    {icon}
                    <span>{currentMessage}</span>
                </div>
            );
        };

        const LevelSelector = () => (
            <div className="space-y-6">
                
                <div className="flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
                    <h2 className="text-3xl font-bold text-gray-100 flex items-center">
                        <Icons.Zap className="mr-3 text-yellow-400" size={28} /> Select Difficulty Level
                    </h2>
                    
                    {/* NEW: Buttons container for flexibility */}
                    <div className="flex space-x-4">
                        {/* NEW: Settings Button */}
                        <button
                            onClick={() => setShowSettings(true)}
                            className="py-2 px-4 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.Settings size={20} className="mr-2" /> Settings
                        </button>
                        
                        {/* EXISTING: How to Play Button */}
                        <button
                            onClick={() => setShowHelp(true)}
                            className="py-2 px-4 bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.HelpCircle size={20} className="mr-2" /> How to Play
                        </button>
                    </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    {Object.keys(LEVELS).map(key => {
                        const level = LEVELS[key];
                        const color = key === 'EASY' ? 'bg-green-600 hover:bg-green-700' :
                                      key === 'MEDIUM' ? 'bg-blue-600 hover:bg-blue-700' :
                                      'bg-red-600 hover:bg-red-700';

                        return (
                            <button
                                key={key}
                                onClick={() => startLevel(key)}
                                disabled={loading}
                                className={`p-6 rounded-xl text-white font-extrabold shadow-xl transition-all duration-300 transform hover:scale-[1.05] disabled:opacity-50 ${color}`}
                            >
                                <div className="text-2xl mb-1">{level.name}</div>
                                <div className="text-sm opacity-80 mb-2">{level.description}</div>
                                <div className="text-xs italic">({level.length} letters)</div>
                            </button>
                        );
                    })}
                </div>
                
                <CustomWordSetup />
            </div>
        );

        const CustomWordSetup = () => {
            // Initial state for custom words
            const initialLength = 4;
            // Use placeholder words that are valid for the initial length
            const [customStart, setCustomStart] = useState('word'); 
            const [customTarget, setCustomTarget] = useState('game');
            const [customLength, setCustomLength] = useState(initialLength);
            // Custom setup should be collapsed by default on MENU, but open if validation failed (SETUP status)
            const [showInput, setShowInput] = useState(status === GAME_STATUS.SETUP);
            
            // Generate list of lengths (3, 4, 5, 6), ensuring 6 is an option
            const lengthOptions = Object.values(LEVELS).map(l => l.length);
            if (!lengthOptions.includes(6)) lengthOptions.push(6);
            lengthOptions.sort((a, b) => a - b); // Ensure 3, 4, 5, 6 order

            // Auto-truncate/update words when length changes
            useEffect(() => {
                const s = customStart.toLowerCase().trim().slice(0, customLength);
                const t = customTarget.toLowerCase().trim().slice(0, customLength);
                setCustomStart(s);
                setCustomTarget(t);
            }, [customLength]);

            // If we are in SETUP status (meaning a validation error occurred), open the panel
            useEffect(() => {
                if (status === GAME_STATUS.SETUP) {
                    setShowInput(true);
                }
            }, [status]);


            const handleCustomStart = () => {
                // Pass current state values to resetGame, which handles all validation
                resetGame(customStart, customTarget, customLength, true);
            };

            const isButtonDisabled = customStart.length !== customLength || 
                                     customTarget.length !== customLength ||
                                     customStart.trim() === '' ||
                                     customTarget.trim() === '' ||
                                     customStart.toLowerCase() === customTarget.toLowerCase() ||
                                     loading;


            return (
                <div className="p-6 bg-gray-700/60 rounded-xl shadow-2xl space-y-4 backdrop-blur-md border border-purple-500/50">
                    <button 
                        onClick={() => setShowInput(!showInput)}
                        className="w-full text-left py-2 text-lg font-bold text-purple-300 flex items-center justify-between"
                    >
                        Custom Level Setup
                        <Icons.ChevronRight className={`transition-transform duration-300 ${showInput ? 'rotate-90' : ''}`} />
                    </button>
                    
                    {showInput && (
                        <div className="space-y-4 pt-2">
                             <div className="flex items-center space-x-3">
                                <label className="text-gray-300 min-w-[100px] font-semibold">Word Length:</label>
                                <select 
                                    value={customLength} 
                                    onChange={(e) => {
                                        setCustomLength(parseInt(e.target.value));
                                        // Clear any previous error message when changing length
                                        setMessage('');
                                    }}
                                    className="p-2 rounded-lg bg-gray-600 text-white focus:ring-2 focus:ring-purple-400 border border-transparent transition cursor-pointer"
                                >
                                    {lengthOptions.map(l => (
                                        <option key={l} value={l}>{l} Letters</option>
                                    ))}
                                </select>
                            </div>

                            <div className="flex flex-col sm:flex-row gap-4">
                                {/* Start Word Input */}
                                <input
                                    type="text"
                                    // Display in uppercase but store in lowercase
                                    value={customStart.toUpperCase()} 
                                    onChange={(e) => setCustomStart(e.target.value.toLowerCase().replace(/[^a-z]/g, '').slice(0, customLength))}
                                    placeholder={`Start Word (${customLength} letters)`}
                                    className={`flex-1 p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 border transition font-mono-game uppercase 
                                        ${customStart.length === customLength ? 'border-green-400' : 'border-red-400'}`}
                                    maxLength={customLength}
                                />
                                {/* Target Word Input */}
                                <input
                                    type="text"
                                    value={customTarget.toUpperCase()}
                                    onChange={(e) => setCustomTarget(e.target.value.toLowerCase().replace(/[^a-z]/g, '').slice(0, customLength))}
                                    placeholder={`Target Word (${customLength} letters)`}
                                    className={`flex-1 p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 border transition font-mono-game uppercase
                                        ${customTarget.length === customLength ? 'border-green-400' : 'border-red-400'}`}
                                    maxLength={customLength}
                                />
                            </div>
                            <button
                                onClick={handleCustomStart}
                                className="w-full py-3 bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                disabled={isButtonDisabled}
                            >
                                <Icons.RefreshCw size={20} className="mr-2" /> Start Custom Level
                            </button>
                            {isButtonDisabled && !loading && (
                                <p className="text-sm text-red-400 text-center">
                                    Please ensure both words are exactly {customLength} letters long, contain only letters, and are different.
                                </p>
                            )}
                        </div>
                    )}
                </div>
            );
        };


        const WordTile = ({ word, pathIndex }) => {
            const isLastWord = pathIndex === currentPath.length - 1;
            const isStartWord = pathIndex === 0;
            const isTargetWord = word === targetWord;
            
            // If it's the last word in the chain, use the word being edited (currentEditWord) for display,
            // otherwise use the established word (word).
            const displayWord = isLastWord ? currentEditWord : word;
            const letters = displayWord.split('');
            const isActive = isLastWord && status === GAME_STATUS.PLAYING && !loading;

            const baseColor = isStartWord 
                ? 'bg-purple-600/70 text-white' 
                : isTargetWord 
                    ? 'bg-green-600/70 text-white' 
                    : 'bg-gray-700/50 text-gray-200';

            // Non-active words are shown simply
            if (!isActive) {
                return (
                    <div className={`p-3 rounded-xl shadow-lg font-mono-game text-xl uppercase transition-all duration-300 transform ${baseColor}`}>
                        {word}
                    </div>
                );
            }
            
            // Active word display: dynamically sized letters
            const letterSizeClass = wordLength === 3 ? 'w-12 h-12 text-4xl' : wordLength === 4 ? 'w-10 h-10 text-3xl' : wordLength === 5 ? 'w-8 h-8 text-2xl' : 'w-7 h-7 text-xl';

            return (
                <div
                    className={`flex justify-center items-center rounded-xl shadow-xl font-mono-game uppercase tracking-widest p-2 transition-all duration-300 
                        ${isActive ? 'bg-gray-700 ring-4 ring-yellow-500/80' : 'bg-gray-800'}`}
                >
                    {letters.map((char, charIndex) => (
                        <div
                            key={charIndex}
                            className={`flex items-center justify-center m-1 rounded-lg font-extrabold cursor-pointer transition-all duration-150 
                                ${letterSizeClass}
                                ${editingIndex === charIndex 
                                    ? 'bg-red-500 text-white shadow-inner ring-2 ring-red-300' // Editing state
                                    : (char !== lastWord[charIndex] 
                                        ? 'bg-blue-500 text-white hover:bg-blue-600 ring-2 ring-blue-300' // Changed letter preview
                                        : 'bg-gray-600/50 text-white hover:bg-gray-600' // Unchanged letter
                                    )
                                }`
                            }
                            onClick={() => isActive && handleLetterClick(charIndex)}
                        >
                            {char}
                            {/* Flashing cursor effect on active editing letter */}
                            {editingIndex === charIndex && <div className="absolute w-1 h-3 bg-white animate-pulse" style={{ animationDuration: '0.8s' }}></div>}
                        </div>
                    ))}
                </div>
            );
        };
        
        const WordPathDisplay = () => {
            // FIX: Ref for auto-scrolling
            const scrollRef = useRef(null); 

            // FIX: Auto-scroll effect
            useEffect(() => {
                if (scrollRef.current) {
                    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                }
            }, [currentPath]);

            return (
                <div className="p-6 bg-gray-800/80 rounded-xl shadow-inner space-y-4">
                    <h2 className="text-2xl font-bold text-gray-200">Your Chain</h2>
                    {/* FIX: Set max-height to 200px (scroll after 3 words) and attach ref. Added pr-2 for scrollbar. */}
                    <div 
                        ref={scrollRef}
                        className="flex flex-col space-y-3 pr-2" 
                        style={{ maxHeight: '200px', overflowY: 'auto' }} 
                    >
                        {currentPath.map((word, index) => {
                            return (
                                <div key={index} className="flex items-center">
                                    {/* Step count display */}
                                    <div className="min-w-10 text-center font-bold text-lg text-gray-400 pr-4">{index + 1}.</div>
                                    {/* The word tile itself */}
                                    {/* FIX: Added my-1 wrapper to prevent outline cut-off */}
                                    <div className="my-1">
                                        <WordTile word={word} pathIndex={index} />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- Main Render Logic ---
        
        const renderGameContent = () => {
            // Only render the full game board if we are actively playing or have won.
            if (status === GAME_STATUS.PLAYING || status === GAME_STATUS.WON) {
                
                const isUndoDisabled = currentPath.length <= 1 || loading;
                
                return (
                    <>
                        {/* Game Info and Action Panel */}
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            
                            {/* Stats Panel */}
                            <div className="p-6 bg-gray-800/60 rounded-xl shadow-2xl space-y-3 backdrop-blur-md lg:col-span-1 border border-gray-700">
                                <h3 className="text-xl font-bold text-gray-100 mb-3 border-b border-gray-600 pb-2">Game Stats</h3>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.BookOpen className="mr-2 text-green-400" size={18} /> Goal Word:</span>
                                    <span className="font-extrabold text-xl text-green-400 uppercase font-mono-game">{targetWord}</span>
                                </div>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.Hash className="mr-2 text-yellow-400" size={18} /> Steps Taken:</span>
                                    <span className="font-extrabold text-xl text-yellow-400 font-mono-game">{currentPath.length - 1}</span>
                                </div>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.Zap className="mr-2 text-purple-400" size={18} /> Word Length:</span>
                                    <span className="font-extrabold text-xl text-purple-400 font-mono-game">{wordLength}</span>
                                </div>
                            </div>
                            
                            {/* Message Display and Control Buttons */}
                            <div className="lg:col-span-2 space-y-4">
                                <MessageDisplay />
                                
                                {(status === GAME_STATUS.PLAYING) && (
                                    <div className="flex flex-col sm:flex-row gap-4">
                                        {/* Undo Button */}
                                        <button
                                            onClick={undoLastMove}
                                            className="flex-1 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                            disabled={isUndoDisabled}
                                            title={isUndoDisabled ? "Cannot undo the starting word" : "Undo the last move"}
                                        >
                                            <Icons.RotateCcw size={20} className="mr-2" /> Undo Last Move
                                        </button>

                                        {/* Quit Button */}
                                        <button
                                            onClick={quitGame}
                                            className="flex-1 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                            disabled={loading}
                                        >
                                            <Icons.LogOut size={20} className="mr-2" /> Quit Game
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>


                        {/* Word Path Display (only show if path exists) */}
                        {currentPath.length > 0 && <WordPathDisplay />}
                    </>
                );
            }

            // Status is MENU or SETUP (failed validation or initializing Custom Level)
            // Render the LevelSelector, which contains the CustomWordSetup component.
            return <LevelSelector />;
        };
        
        return (
            <div className="min-h-screen bg-gray-900 text-white p-4 sm:p-8 flex justify-center items-start pt-10">
                <div className="w-full max-w-4xl space-y-8">
                    {/* Title and Header - NAME IS WORD CHAIN */}
                    <header className="text-center space-y-2 mb-8">
                        <h1 className="text-7xl font-extrabold tracking-wide text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
                            The Word Ladder Game
                        </h1>
                        <p className="text-lg text-gray-400 italic">
                            {status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP 
                                ? "Solve the word puzzle by changing one letter at a time!" 
                                : "Click a letter in the active word, then type a new letter to form the next valid word."
                            }
                        </p>
                    </header>
                    
                    {/* Message is shown above the LevelSelector if status is MENU/SETUP and an error exists */}
                    {(status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP) && message && <MessageDisplay />}
                    
                    {renderGameContent()}

                    {/* NEW: Settings Modal */}
                    {showSettings && (
                        <SettingsModal 
                            onClose={() => setShowSettings(false)} 
                            allowCurseWords={allowCurseWords}
                            setAllowCurseWords={setAllowCurseWords}
                        />
                    )}

                    {/* EXISTING: Help Modal */}
                    {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
                    
                    {/* NEW: Win Modal */}
                    {status === GAME_STATUS.WON && (
                        <WinModal 
                            chain={currentPath}
                            steps={currentPath.length - 1}
                            onNewGame={quitGame}
                            // Note: resetGame needs startWord, targetWord, wordLength, and isCustom=false
                            onReplay={() => resetGame(startWord, targetWord, wordLength, false)}
                            startWord={startWord}
                            targetWord={targetWord}
                        />
                    )}
                </div>
            </div>
        );
    };

    // Render the React component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

</body>
</html>