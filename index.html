<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Word Ladder Game - Levels</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Use Inter and Space Mono for a clean, modern, and code-like look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom font for words to give it a game feel */
        .font-mono-game {
            font-family: 'Space Mono', monospace;
        }        
		/* Custom Scrollbar Styles for Theme Consistency */
        .custom-scrollbar::-webkit-scrollbar {
            height: 8px; /* Height for horizontal scrollbar */
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2D3748; /* Dark Gray (match background or track color) */
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4A5568; /* Slightly lighter gray for the thumb */
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #38B2AC; /* Teal color on hover */
        }
    </style>
</head>
<body class="bg-gray-900">

<div id="root">
    </div>

<script type="text/babel">
    const { useState, useCallback, useEffect, useMemo, useRef } = window.React; 
    const ReactDOM = window.ReactDOM;

    // --- ICON Definitions ---
    const Icons = {
		RefreshCw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4"/></svg>,        
        CheckCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="M9 11l3 3L22 4"/></svg>,
        XCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6"/><path d="M9 9l6 6"/></svg>,
        ChevronRight: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
        Hash: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>,
        BookOpen: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
        Loader: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a10 10 0 1 0 5.4 18.5"/><path d="M12 2v2"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M17.4 6.6l-1.4 1.4"/><path d="M6.6 17.4l-1.4 1.4"/></svg>,
        Zap: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
		Trophy: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 13c0 2.038-2.239 4.5-5 4.5S7 15.038 7 13c0 1.444 10 1.444 10 0Z"/><path fill="currentColor" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/></svg>,        
        LogOut: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
		RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 9h13a5 5 0 0 1 0 10H7M3 9l4-4M3 9l4 4"/></svg>,        
        HelpCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>,
		Settings: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="square" strokeLinejoin="round" strokeWidth="2" d="M10 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h2m10 1a3 3 0 0 1-3 3m3-3a3 3 0 0 0-3-3m3 3h1m-4 3a3 3 0 0 1-3-3m3 3v1m-3-4a3 3 0 0 1 3-3m-3 3h-1m4-3v-1m-2.121 1.879-.707-.707m5.656 5.656-.707-.707m-4.242 0-.707.707m5.656-5.656-.707.707M12 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/></svg>,
		};

    // --- LEVEL CONFIGURATION (Used by LevelSelector) ---
    const LEVELS = {
        EASY: { 
            name: '3-Letter Warmup', 
            description: 'Quick puzzles with small words.',
            length: 3, 
            pairs: [
                { start: 'cat', target: 'dog' },
                { start: 'pig', target: 'pen' },
                { start: 'sun', target: 'day' },
                { start: 'run', target: 'kid' },
                { start: 'try', target: 'buy' },
                { start: 'top', target: 'can' },
                { start: 'why', target: 'how' },
                { start: 'low', target: 'new' },
                { start: 'fix', target: 'met' },
                { start: 'red', target: 'dad' }
            ]
        },
        MEDIUM: { 
            name: '4-Letter Standard', 
            description: 'The classic Word Chain experience.',
            length: 4, 
            pairs: [
                { start: 'cool', target: 'book' },
                { start: 'word', target: 'game' },
                { start: 'make', target: 'lake' },
                { start: 'slow', target: 'fast' },
                { start: 'lead', target: 'gold' },
                { start: 'home', target: 'cave' },
                { start: 'ship', target: 'boat' },
                { start: 'four', target: 'five' },
                { start: 'mind', target: 'move' },
                { start: 'fall', target: 'rise' }
            ]
        },
        HARD: { 
            name: '5-Letter Challenge', 
            description: 'Longer words requiring careful thought.',
            length: 5, 
            pairs: [
                { start: 'drive', target: 'dream' },
                { start: 'plane', target: 'glass' },
                { start: 'crane', target: 'stack' },
                { start: 'light', target: 'heavy' },
                { start: 'wheat', target: 'bread' },
                { start: 'smart', target: 'dummy' },
                { start: 'solve', target: 'proof' },
                { start: 'stone', target: 'money' },
                { start: 'train', target: 'wheel' },
                { start: 'heart', target: 'break' }
            ]
        }
    };

    // --- BASIC HARDCODED PROFANITY LIST for demonstration ---
    const PROFANITY_LIST = [
        'shit', 'fuck', 'ass', 'bitch', 'cunt', 'piss', 'nigga', 'boob',
        'wank', 'dick', 'crap', 'pube', 'slut', 'tits', 'cock', 'boobs'
    ];

    // Dictionary API for word validation
    const API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
    const MAX_RETRIES = 3;
	
	// Whitelist for common, short words that the live API might occasionally fail to find.
    const LOCAL_WORD_WHITELIST = [
        'look', 'good', 'door', 'fish', 'four', 'five', 'tree', 'zero', 'jump', 'move', 'hold', 'send'
    ];

    /**
     * Checks word validity using the Dictionary API and an internal profanity filter.
     */
    const checkWordValidity = async (word, allowCurseWords, retries = 0) => {
        const cleanedWord = word.trim().toLowerCase();
        if (cleanedWord === '') return false;

        // --- PROFANITY CHECK ---
        if (!allowCurseWords && PROFANITY_LIST.includes(cleanedWord)) {
            return false; // Invalidated due to profanity
        }
        // --- END PROFANITY CHECK ---
		
        if (LOCAL_WORD_WHITELIST.includes(cleanedWord)) {
            return true;
        }
        const url = `${API_URL}${cleanedWord}`;
        
        try {
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                return Array.isArray(data);
            } else if (response.status === 404) {
                return false;
            } else {
                throw new Error(`API returned status ${response.status}`);
            }
        } catch (error) {
            if (retries < MAX_RETRIES) {
                const delay = Math.pow(2, retries) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
                return checkWordValidity(word, allowCurseWords, retries + 1); 
            }
            console.error(`Failed to check word validity for "${word}" after ${MAX_RETRIES} retries:`, error);
            return false; 
        }
    };

    /**
     * Checks if the current word is exactly one letter different from the previous word.
     */
    const isOneLetterDifference = (prevWord, currentWord) => {
        if (prevWord.length !== currentWord.length) return false;
        let diffCount = 0;
        for (let i = 0; i < prevWord.length; i++) {
            if (prevWord[i] !== currentWord[i]) {
                diffCount++;
            }
        }
        return diffCount === 1;
    };

    // --- MODAL Components (Settings, Help, Win) ---
    
    // --- HELP MODAL COMPONENT ---
    // --- HELP MODAL COMPONENT (REVISED FOR COMPACT LAYOUT AND CORRECT JSX) ---
    const HelpModal = ({ onClose }) => {
        // Data Setup (Rules 2, 3, 4 only)
        const rules = [
            "You can change only one letter from the current word to form the next one.", 
            "Each word in the chain must be a valid English word.", 
            "You cannot reuse a word already in your chain."
        ];

        // Visual examples for the rules (small size)
        const oneLetterDiffExample = [{ word: "CAT", valid: true, color: 'bg-purple-600' }, { word: "COT", valid: true, color: 'bg-gray-600' }];
        const invalidWordExample = [
            { chain: [{ word: "COT", valid: true, color: 'bg-gray-600' }, { word: "COG", valid: true, color: 'bg-gray-600' }], type: "valid" },
            { chain: [{ word: "COT", valid: true, color: 'bg-gray-600' }, { word: "CPG", valid: false, color: 'bg-gray-500' }], type: "invalid" }
        ];
        const reuseWordExample = [{ word: "COT", valid: true, color: 'bg-gray-600' }, { word: "COG", valid: true, color: 'bg-gray-600' }, { word: "COT", valid: false, color: 'bg-gray-500' }];

        // The solution chain for the final example (consistent small size)
        const solutionChain = [
            { word: "CAT", color: "bg-purple-600" }, 
            { word: "COT", color: "bg-gray-600" }, 
            { word: "COG", color: "bg-gray-600" }, 
            { word: "DOG", color: "bg-green-600" }
        ];

        // Component to render a word block for rules (small size)
        const WordBlock = ({ word, color, valid }) => (
             <span className={`px-2 py-0.5 rounded-md font-mono-game text-sm font-bold uppercase ${color} text-white ${!valid ? 'opacity-70' : ''}`}>
                 {word}
             </span>
        );
        
        // Component to render the shared yellow-bordered container
        const ExampleContainer = ({ children }) => (
            // Reduced padding, margin-top, and removed space-y-3
            <div className="p-2 bg-gray-800 rounded-lg shadow-inner border border-yellow-500/80 mt-1"> 
                {children}
            </div>
        );


        return (
            <div 
                className="fixed inset-0 z-50 flex items-center justify-center p-2 bg-black bg-opacity-70 backdrop-blur-sm" 
                onClick={onClose}
            >
                <div 
                    // Set max-h to a percentage that should fit most screens without scroll
                    className="w-full max-w-xl max-h-[85vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-4 space-y-4 transform transition-all" 
                    onClick={(e) => e.stopPropagation()} 
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-2 mb-2">
                        <h2 className="text-2xl font-extrabold text-purple-400 flex items-center">
                            <Icons.HelpCircle className="mr-2" size={24} /> How To Play
                        </h2>
                        <button onClick={onClose} className="p-1 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={24} />
                        </button>
                    </div>

                    <div className="space-y-4"> 
                        <div className="p-3 bg-gray-700/60 rounded-lg border-l-4 border-purple-500 shadow-md">
                            
                            {/* INTRODUCTORY PARAGRAPH (REPLACING THE FIRST RULE) */}
                            <p className="text-lg font-bold text-gray-100 mb-3 flex flex-wrap items-center leading-snug">
                                To transform the <strong className="text-purple-400 mx-1">Start Word</strong>
                                <span className="inline-block px-1.5 py-0.5 rounded-md font-mono-game text-base font-bold uppercase bg-purple-600 text-white shadow-md mx-0.5">
                                    CAT
                                </span>
                                into the <strong className="text-green-400 mx-1">Goal Word</strong>
                                <span className="inline-block px-1.5 py-0.5 rounded-md font-mono-game text-base font-bold uppercase bg-green-600 text-white shadow-md mx-0.5">
                                    DOG
                                </span>
                                you must follow these rules:
                            </p>

                            <ul className="list-disc list-inside text-gray-300 space-y-3 pl-2 pt-3 border-t border-gray-700/50">
                                
                                {/* Rule 1 (was Rule 2): One Letter Difference */}
                                <li className="text-base font-medium leading-tight">
                                    {rules[0]}
                                    <ExampleContainer>
                                        <div className="flex items-center gap-1">
                                            {oneLetterDiffExample.map((item, idx) => (
                                                <React.Fragment key={idx}>
                                                    <WordBlock word={item.word} color={item.color} valid={item.valid} />
                                                    {idx < oneLetterDiffExample.length - 1 && <span className="text-gray-400 text-base">&rarr;</span>}
                                                </React.Fragment>
                                            ))}
                                        </div>
                                    </ExampleContainer>
                                </li>

                                {/* Rule 2 (was Rule 3): Valid English Word (Fixed JSX structure) */}
                                <li className="text-base font-medium leading-tight">
                                    {rules[1]}
                                    <ExampleContainer>
                                        <div className="flex flex-wrap items-center gap-2">
                                            {invalidWordExample.map((example, exIdx) => (
                                                <div key={exIdx} className="flex items-center gap-1">
                                                    {example.chain.map((item, idx) => (
                                                        <React.Fragment key={idx}>
                                                            <WordBlock word={item.word} color={item.color} valid={item.valid} />
                                                            {idx < example.chain.length - 1 && <span className="text-gray-400 text-base">&rarr;</span>}
                                                        </React.Fragment>
                                                    ))}
                                                    {/* The JSX below is correctly wrapped in a Fragment if needed, or is a single component */}
                                                    {example.type === "valid" ? (
                                                        <Icons.CheckCircle size={20} className="text-green-500" /> 
                                                    ) : (
                                                        <Icons.XCircle size={20} className="text-red-500" />
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </ExampleContainer>
                                </li>
                                
                                {/* Rule 3 (was Rule 4): Cannot Reuse Word */}
                                <li className="text-base font-medium leading-tight">
                                    {rules[2]}
                                    <ExampleContainer>
                                        <div className="flex items-center gap-1">
                                            {reuseWordExample.map((item, idx) => (
                                                <React.Fragment key={idx}>
                                                    <WordBlock word={item.word} color={item.color} valid={item.valid} />
                                                    {idx < reuseWordExample.length - 1 && <span className="text-gray-400 text-base">&rarr;</span>}
                                                </React.Fragment>
                                            ))}
                                            <Icons.XCircle size={20} className="text-red-500" />
                                        </div>
                                    </ExampleContainer>
                                </li>
                                
                                {/* Solution/Example */}
                                <li className="text-base font-medium mt-4 pt-3 border-t border-gray-700">
                                    A possible <strong className="text-yellow-400">Solution</strong> for CAT to DOG:
                                    <ExampleContainer>
                                        <div className="flex flex-wrap justify-center sm:justify-start gap-1">
                                            {solutionChain.map((item, index) => (
                                                <React.Fragment key={index}>
                                                    <WordBlock word={item.word} color={item.color} valid={true} /> 
                                                    {index < solutionChain.length - 1 && (
                                                        <span className="flex items-center text-gray-400 text-base">&rarr;</span>
                                                    )}
                                                </React.Fragment>
                                            ))}
                                        </div>
                                    </ExampleContainer>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    // --- SETTINGS MODAL COMPONENT ---
    const SettingsModal = ({ onClose, allowCurseWords, setAllowCurseWords }) => {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
                <div 
                    className="w-full max-w-md max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6 transform transition-all"
                    onClick={(e) => e.stopPropagation()} 
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-3">
                        <h2 className="text-3xl font-extrabold text-purple-400 flex items-center">
                            <Icons.Settings className="mr-3" size={30} /> Game Settings
                        </h2>
                        <button onClick={onClose} className="p-2 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={28} />
                        </button>
                    </div>

                    <div className="space-y-4">
                        <div className="flex justify-between items-center p-4 bg-gray-700/50 rounded-lg border-l-4 border-blue-500 shadow-md">
                            <div>
                                <h3 className="text-xl font-bold text-gray-100">Allow Profanity</h3>
                                <p className="text-sm text-gray-300">Allow potentially offensive or sensitive words.</p>
                            </div>
                            <button
                                onClick={() => setAllowCurseWords(prev => !prev)}
                                className={`relative inline-flex items-center h-8 w-14 rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 ${allowCurseWords ? 'bg-green-600' : 'bg-gray-600'}`}
                            >
                                <span className="sr-only">Toggle Profanity Filter</span>
                                <span
                                    className={`inline-block w-6 h-6 transform bg-white rounded-full transition-transform ${allowCurseWords ? 'translate-x-6' : 'translate-x-1'}`}
                                ></span>
                            </button>
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700">
                        <button
                            onClick={onClose}
                            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200"
                        >
                            Close Settings
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- WIN MODAL COMPONENT ---
    const WinModal = ({ chain, steps, onNewGame, onReplay, startWord, targetWord }) => {
        return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-80 backdrop-blur-sm">
                <div 
                    className="w-full max-w-4xl max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 space-y-6 transform transition-all border-4 border-green-500"
                >
                    <div className="text-center space-y-4">
                        <Icons.Trophy className="mx-auto text-yellow-400" size={60} />
                        <h3 className="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-teal-500 break-words">
                            CONGRATULATIONS!
                        </h3>
                        <p className="text-2xl font-semibold text-gray-200">
                            You solved the puzzle in <span className="text-yellow-400">{steps}</span> steps!
                        </p>
                    </div>

                    <div className="space-y-3">
                        <h3 className="text-xl font-bold text-gray-300 border-b border-gray-700 pb-2">Your Winning Chain:</h3>
                        <div className="flex flex-wrap justify-center gap-2 max-h-[200px] overflow-y-auto p-2 border border-gray-700 rounded-lg bg-gray-900/50">
                            {chain.map((word, index) => (
                                <div 
                                    key={index}
                                    className={`px-4 py-2 rounded-lg font-mono-game text-xl font-bold uppercase transition-all duration-300 shadow-md
                                        ${word === startWord ? 'bg-purple-600 text-white' :
                                          word === targetWord ? 'bg-green-600 text-white' :
                                          'bg-gray-600 text-white'
                                        }`}
                                >
                                    {word}
                                    {index < chain.length - 1 && (
                                        <span className="ml-2 text-gray-400">â†’</span>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700 flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button
                            onClick={onNewGame}
                            className="flex-1 px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.BookOpen size={20} className="mr-2" /> New Game
                        </button>
                        
                        <button
                            onClick={onReplay}
                            className="flex-1 px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.RefreshCw size={20} className="mr-2" /> Replay
                        </button>
                    </div>
                </div>
            </div>
        );
    };


    // --- MAIN APP COMPONENT ---

    const App = () => {
        const [startWord, setStartWord] = useState('');
        const [targetWord, setTargetWord] = useState('');
        const [wordLength, setWordLength] = useState(0);
        const [currentPath, setCurrentPath] = useState([]); // Array of words in the chain
        const [status, setStatus] = useState('MENU'); // MENU, PLAYING, WON, SETUP
        const [message, setMessage] = useState('');
        const [loading, setLoading] = useState(false);
        
        // State for Help/Settings Modal
        const [showHelp, setShowHelp] = useState(false); 
        const [showSettings, setShowSettings] = useState(false);
        const [allowCurseWords, setAllowCurseWords] = useState(false); 

        // State for managing the letter currently being edited
        const [editingIndex, setEditingIndex] = useState(null); // Index of the letter being edited
        const [currentEditWord, setCurrentEditWord] = useState(''); // The word being typed/previewed before submission
        
        const pathContainerRef = useRef(null); 
        
        const lastWord = useMemo(() => currentPath[currentPath.length - 1], [currentPath]);

        useEffect(() => {
            setCurrentEditWord(lastWord || '');
        }, [lastWord]);

        const GAME_STATUS = {
            MENU: 'MENU',
            PLAYING: 'PLAYING',
            WON: 'WON',
            SETUP: 'SETUP' 
        };

        const submitWord = useCallback(async (submittedWord) => {
            setMessage('');
            setLoading(true);
            
            setEditingIndex(null);

            if (submittedWord.length !== wordLength) {
                setMessage(`Word must be exactly ${wordLength} letters long.`);
                setLoading(false);
                setCurrentEditWord(lastWord);
                return;
            }

            if (!isOneLetterDifference(lastWord, submittedWord)) {
                setMessage(`The new word "${submittedWord.toUpperCase()}" must differ by only one letter from "${lastWord.toUpperCase()}".`);
                setLoading(false);
                setCurrentEditWord(lastWord); 
                return;
            }
            
            if (currentPath.includes(submittedWord)) {
                setMessage(`"${submittedWord.toUpperCase()}" is already in your chain. Try a new word.`);
                setLoading(false);
                setCurrentEditWord(lastWord); 
                return;
            }
            
            setMessage(`Checking "${submittedWord.toUpperCase()}" in the live dictionary...`);
            const isValid = await checkWordValidity(submittedWord, allowCurseWords);
            setLoading(false);
            
            if (!isValid) {
                let failMessage = `"${submittedWord.toUpperCase()}" is not recognized as a valid word. Try again.`;
                if (!allowCurseWords && PROFANITY_LIST.includes(submittedWord)) {
                    // Added a tag to easily identify profanity blocks in MessageDisplay
                    failMessage = `[Profanity Block] Profanity not allowed.`; 
                }
                setMessage(failMessage);
                setCurrentEditWord(lastWord); 
                return;
            }

            const newPath = [...currentPath, submittedWord];
            setCurrentPath(newPath);
            
            if (submittedWord === targetWord) {
                setMessage(`ðŸŽ‰ CONGRATULATIONS! You solved the chain in ${newPath.length - 1} steps!`);
                setStatus(GAME_STATUS.WON);
            } else {
                setMessage('Excellent move! Keep going, one letter at a time.');
            }
            
        }, [lastWord, currentPath, targetWord, wordLength, allowCurseWords]); 


        /**
         * Unified game start/reset function
         */
        const resetGame = useCallback(async (start, target, length, isCustom = false) => {
            const s = start.toLowerCase().trim();
            const t = target.toLowerCase().trim();
            
            setEditingIndex(null);
            setMessage('');

            // --- Word Length Validation ---
            if (s.length !== length || t.length !== length || s.length === 0) {
                const source = isCustom ? 'custom setup' : 'level configuration';
                // Added tag for validation errors
                setMessage(`[Validation Error from ${source.toUpperCase()}]: Both words must be exactly ${length} letters long.`);
                setStatus(GAME_STATUS.MENU);
                return;
            }

            // --- Note: Custom checks removed for simplification. Only official levels are now used. ---

            setWordLength(length);
            
            setLoading(true);
            setMessage('Validating words via API...');

            // For simplicity and stability, we skip API check for hardcoded levels, assuming they are valid.
            // If isCustom was true, we'd do the check, but Custom is removed.

            setLoading(false);

            // Success
            setStartWord(s);
            setTargetWord(t);
            setCurrentPath([s]);
            setCurrentEditWord(s);
            setMessage(`Tap a letter to begin typing.`); // Updated message to match image style
            setStatus(GAME_STATUS.PLAYING);
        }, [allowCurseWords]); 

        const startLevel = (levelKey) => {
            const level = LEVELS[levelKey];
            const pair = level.pairs[Math.floor(Math.random() * level.pairs.length)];
            // isCustom is false since we only start built-in levels now
            resetGame(pair.start, pair.target, level.length, false); 
        };
        
        const quitGame = () => {
            setStartWord('');
            setTargetWord('');
            setWordLength(0);
            setCurrentPath([]);
            setMessage('');
            setEditingIndex(null);
            setCurrentEditWord('');
            setStatus(GAME_STATUS.MENU);
        };

        // --- Undo Last Move Function ---
        const undoLastMove = useCallback(() => {
            if (currentPath.length > 1 && status === GAME_STATUS.PLAYING && !loading) {
                const newPath = currentPath.slice(0, -1); 
                const newLastWord = newPath[newPath.length - 1];
                
                setCurrentPath(newPath);
                setCurrentEditWord(newLastWord);
                setEditingIndex(null); 
                setMessage(`Move undone. Current word is ${newLastWord.toUpperCase()}.`);
            }
        }, [currentPath, status, loading]);

        // --- Letter Click Logic (Start/Cancel Editing) ---

        const handleLetterClick = useCallback((index) => {
        if (status !== GAME_STATUS.PLAYING || loading) return;

        if (editingIndex === index) {
            setEditingIndex(null);
            setMessage('Tap a letter to begin typing.');
            setCurrentEditWord(lastWord);
        } else {
            setEditingIndex(index);
            setMessage(`Enter the new letter for position ${index + 1}.`);
        }
    }, [status, loading, editingIndex, lastWord]);

        // --- Input Change Handler ---

        const handleInputChange = useCallback((event) => {
            const newChar = event.target.value.toLowerCase().slice(-1); 

            if (newChar.match(/^[a-z]$/) && newChar.length === 1) {
                
                const newWord = lastWord.split(''); 
                
                if (newWord[editingIndex] === newChar) {
                    setMessage('You must change the letter at the selected position.');
                    event.target.value = ''; 
                    tempInputRef.current?.blur();
                    return;
                }
                
                newWord[editingIndex] = newChar;
                const potentialWord = newWord.join('');
                
                setCurrentEditWord(potentialWord);
                submitWord(potentialWord);
                
                event.target.value = '';
                
            } else {
                event.target.value = ''; 
            }

            tempInputRef.current?.blur();

        }, [editingIndex, lastWord, submitWord]);
        
        // --- Global Keydown Listener for Desktop/Escape ---
        const handleGlobalKeyPress = useCallback((event) => {
            if (status !== GAME_STATUS.PLAYING || loading) return;

            const key = event.key.toLowerCase();
            
            if (key.match(/^[a-z]$/) && key.length === 1 && editingIndex !== null) {
                
                event.preventDefault(); 

                const newWord = lastWord.split(''); 
                
                if (newWord[editingIndex] === key) {
                    setMessage('You must change the letter at the selected position.');
                    return;
                }
                
                newWord[editingIndex] = key;
                const potentialWord = newWord.join('');
                
                setCurrentEditWord(potentialWord);
                submitWord(potentialWord);
                
                setEditingIndex(null);
                
            } else if (key === 'escape') {
                event.preventDefault();
                setEditingIndex(null);
                setMessage('Editing canceled.');
                setCurrentEditWord(lastWord);
            }
        }, [status, loading, editingIndex, lastWord, submitWord]);

        useEffect(() => {
            window.addEventListener('keydown', handleGlobalKeyPress);
            return () => {
                window.removeEventListener('keydown', handleGlobalKeyPress);
            };
        }, [handleGlobalKeyPress]); 


        // --- Global Click Listener for Click-Away-To-Cancel ---
        useEffect(() => {
            if (status !== GAME_STATUS.PLAYING || loading) return;
            if (editingIndex === null) return;
            
            const handleClickOutside = (event) => {
                // Check if the click is outside the path container and also outside the virtual keyboard
                const keyboardElement = document.getElementById('virtual-keyboard');
                
                const isClickOnKeyboard = keyboardElement && keyboardElement.contains(event.target);
                const isClickOnWordTiles = pathContainerRef.current && pathContainerRef.current.contains(event.target);
                
                if (!isClickOnWordTiles && !isClickOnKeyboard) {
                    setEditingIndex(null); 
                    setCurrentEditWord(lastWord);
                    setMessage('Editing canceled.');
                }
            };

            document.addEventListener('mousedown', handleClickOutside);
            
            return () => {
                document.removeEventListener('mousedown', handleClickOutside);
            };
        }, [status, loading, editingIndex, lastWord]);


        // --- UI COMPONENTS ---
        
        const MessageDisplay = () => {
            let currentMessage = message;
            let icon = null;
            let colorClass = 'bg-blue-600';
            let iconSize = 20;

            if (!currentMessage && !loading) return null;

            // Check for error messages (only these conditions result in a red background)
            const isError = currentMessage.includes('[Validation Error]') 
                || currentMessage.includes('[Dictionary Error]') 
                || currentMessage.includes('[Profanity Block]') 
                || currentMessage.includes('differ by only one') 
                || currentMessage.includes('already in your chain')
                || currentMessage.includes('is not recognized as a valid word')
                || currentMessage.includes('You must change the letter at the selected position.') // Explicit validation error
                || currentMessage.includes('Please tap one of the word tiles')

            
            // PRIORITY 1: Loading
            if (loading) {
                currentMessage = message || '...connecting to dictionary...';
                icon = <Icons.Loader size={iconSize} className="animate-spin" />;
                colorClass = 'bg-yellow-600';
            } 
            // PRIORITY 2: Error/Negative Status (FIXED PRIORITY ORDERING)
            else if (isError) { 
                icon = <Icons.XCircle size={iconSize} />;
                // Applying the user's requested brighter error style
                colorClass = 'bg-red-600 border-2 border-red-400 shadow-xl'; 
            } 
            // PRIORITY 3: Win
            else if (status === GAME_STATUS.WON) {
                icon = <Icons.Trophy size={iconSize} />;
                colorClass = 'bg-green-600';
            } 
            // PRIORITY 4: General Playing/Success (Default)
            else if (status === GAME_STATUS.PLAYING) {
                icon = <Icons.CheckCircle size={iconSize} />;
                colorClass = 'bg-blue-600';
            }


            return (
                <div className={`py-2 px-4 rounded-xl shadow-2xl text-white font-semibold flex items-center space-x-3 ${colorClass}`}>
                    {icon}
                    <span>{currentMessage}</span>
                </div>
            );
        };

        const LevelSelector = () => {
            const [showLevelList, setShowLevelList] = useState(false);

            return (
                <div className="space-y-6">
                    
                    <div className="flex flex-col w-full items-center space-y-4">
                        <h2 className="text-3xl font-bold text-gray-100 flex items-center">
                            <Icons.Zap className="mr-3 text-yellow-400" size={28} /> Select Level
                        </h2>
                        
                        <div className="relative w-full max-w-sm">
                            <button
                                onClick={() => setShowLevelList(prev => !prev)}
                                className="w-full py-4 px-6 bg-purple-600 hover:bg-purple-700 text-white font-extrabold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-between disabled:opacity-50"
                                disabled={loading}
                            >
                                Choose a Level...
                                <Icons.ChevronRight size={24} className={`transition-transform duration-300 ${showLevelList ? 'rotate-90' : ''}`} />
                            </button>

                            {showLevelList && (
                                <div className="absolute z-10 w-full mt-2 bg-gray-800 rounded-xl shadow-2xl border border-purple-500/50 p-2 space-y-2">
                                    {Object.keys(LEVELS).map(key => {
                                        const level = LEVELS[key];
                                        const color = key === 'EASY' ? 'bg-green-600 hover:bg-green-700' :
                                                      key === 'MEDIUM' ? 'bg-blue-600 hover:bg-blue-700' :
                                                      'bg-red-600 hover:bg-red-700';
                                        
                                        return (
                                            <button
                                                key={key}
                                                onClick={() => { 
                                                    startLevel(key); 
                                                    setShowLevelList(false); // Close after selection
                                                }}
                                                disabled={loading}
                                                className={`w-full p-3 rounded-lg text-white font-extrabold shadow-md transition-all duration-300 transform hover:scale-[1.01] disabled:opacity-50 ${color} text-left`}
                                            >
                                                <div className="text-xl mb-1">{level.name}</div>
                                                <div className="text-xs opacity-80">{level.description} ({level.length} letters)</div>
                                            </button>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* --- Settings/Help buttons --- */}
                    <div className="flex space-x-4 justify-center pt-4">
                        <button
                            onClick={() => setShowSettings(true)}
                            className="py-2 px-4 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.Settings size={20} className="mr-2" /> Settings
                        </button>
                        
                        <button
                            onClick={() => setShowHelp(true)}
                            className="py-2 px-4 bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.HelpCircle size={20} className="mr-2" /> How to Play
                        </button>
                    </div>
                </div>
            );
        };


        const WordTile = ({ word, pathIndex }) => {
            const isLastWord = pathIndex === currentPath.length - 1;
            // Removed unused constants: isStartWord, isTargetWord
            
            const displayWord = isLastWord ? currentEditWord : word;
            const letters = displayWord.split('');
            const isActive = isLastWord && status === GAME_STATUS.PLAYING && !loading;

            // Non-active words are now styled similar to the active word but muted
            if (!isActive) {
                const isCurrent = pathIndex === currentPath.length - 1;
                const tileColor = isCurrent ? 'bg-purple-700/90 text-white' : 'bg-gray-700/50 text-gray-200';
                const letterSize = wordLength === 3 ? 'p-4 text-4xl' : wordLength === 4 ? 'p-3 text-3xl' : 'p-2 text-2xl';

                return (
                    <div className="flex justify-center gap-2">
                        {word.split('').map((char, index) => (
                            <div key={index} className={`rounded-xl shadow-lg font-mono-game uppercase font-extrabold transition-all duration-300 ${tileColor} ${letterSize}`}>
                                {char}
                            </div>
                        ))}
                    </div>
                );
            }
            
            // Active word display: dynamically sized letters, styled to match image
            const letterSizeClass = wordLength === 3 ? 'w-14 h-14 text-4xl' : wordLength === 4 ? 'w-12 h-12 text-3xl' : 'w-10 h-10 text-2xl';

            return (
                <div
                    className="flex justify-center items-center font-mono-game uppercase tracking-widest gap-3"
                >
                    {letters.map((char, charIndex) => (
                        <div 
                            key={charIndex} 
                            className={`relative flex items-center justify-center rounded-xl font-extrabold cursor-pointer transition-all duration-150 shadow-xl
                                ${letterSizeClass}
                                ${editingIndex === charIndex 
                                    ? 'bg-red-500 text-white shadow-inner ring-4 ring-red-300/50' 
                                    : (char !== lastWord[charIndex] 
                                        ? 'bg-blue-500 text-white hover:bg-blue-600 ring-4 ring-blue-300/50' 
                                        : 'bg-purple-600 text-white hover:bg-purple-700 ring-4 ring-purple-300/50' 
                                    )
                                }`
                            }
                            onClick={() => isActive && handleLetterClick(charIndex)}
                        >
                            {char}
                            
                            {/* Temporary Input Overlay */}
                           
                        </div>
                    ))}
                </div>
            );
        };
        
        // --- WordPathDisplay component (Custom Scrollbar Applied) ---
const WordPathDisplay = () => {
    // Define a ref to reference the scrollable container element
    const scrollContainerRef = React.useRef(null);

    // Use useEffect to scroll to the right whenever the path changes
    React.useEffect(() => {
        if (scrollContainerRef.current) {
            // Set the horizontal scroll position to the maximum possible value
            scrollContainerRef.current.scrollLeft = scrollContainerRef.current.scrollWidth;
        }
    }, [currentPath]); // Depend on currentPath, so it runs every time a new word is added

    // Only render when playing or won
    if (status === GAME_STATUS.PLAYING || status === GAME_STATUS.WON) {
        const lastIdx = currentPath.length - 1;
        const last = currentPath[lastIdx];

        return (
            <div ref={pathContainerRef} className="flex flex-col items-center gap-4 w-full">
                
                {/* 1. Current Active Word (Always visible) */}
                <WordTile word={last} pathIndex={lastIdx} />

                {/* 2. Full Chain History (Horizontal Scrolling) */}
                {currentPath.length > 0 && (
                    // Outer container to enforce max width and center the scrollable area
                    <div className="w-full max-w-md mx-auto">
                        {/* Inner container: Apply ref, overflow, and the custom-scrollbar class */}
                        <div 
                            ref={scrollContainerRef} // Assign the ref
                            // ADDED: custom-scrollbar class for styling
                            className="flex flex-nowrap overflow-x-auto gap-2 p-2 bg-gray-800/60 rounded-xl shadow-inner border border-gray-700/50 custom-scrollbar"
                        >
                            {currentPath.map((word, index) => (
                                <React.Fragment key={index}>
                                    <span 
                                        className={`flex-shrink-0 px-3 py-1 rounded-md font-mono-game text-sm font-bold uppercase shadow-sm 
                                            ${index === currentPath.length - 1 
                                                ? 'bg-teal-600 text-white' // Highlight the current word
                                                : 'bg-gray-700 text-gray-300' // Previous words
                                            }`
                                        }
                                    >
                                        {word}
                                    </span>
                                    {/* Show arrow only if it's NOT the very last word in the whole chain */}
                                    {index < currentPath.length - 1 && (
                                        <span className="flex items-center text-gray-500 text-lg flex-shrink-0">&rarr;</span>
                                    )}
                                </React.Fragment>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        );
    }
    
    return null; // Don't render if not playing or won
};
// --- End WordPathDisplay component ---

        // --- Virtual Keyboard Component ---
        const VirtualKeyboard = ({ onKeyPress }) => {
    const rows = [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
        ['Z', 'X', 'C', 'V', 'B', 'N', 'M']
    ];

    const handleKeyClick = (key) => {
        if (key.length === 1 && editingIndex !== null) {
            // Simulate the global keypress event logic
            const event = {
                key: key.toLowerCase(),
                preventDefault: () => {} // Mock preventDefault
            };
            handleGlobalKeyPress(event);
        } else {
            // Added a message for better UX now that keys are always enabled but only functional when a tile is selected
            setMessage(`Please tap one of the word tiles above to select a letter position before typing.`);
        }
    };
            
    const baseKeyClass = "p-3 rounded-lg text-white font-extrabold text-lg transition-colors duration-150 shadow-md transform active:scale-95";
    const enabledKeyClass = "bg-gray-700 hover:bg-gray-600";
    // The disabledKeyClass is removed entirely

    return (
        // FIX: Changed p-4 to p-2 for less external padding
        <div id="virtual-keyboard" className="w-full max-w-xl mx-auto p-2 rounded-xl bg-gray-800 shadow-2xl space-y-2">
            {rows.map((row, rowIndex) => (
                <div 
                    key={rowIndex} 
                    // FIX: Changed gap-2 to gap-1 for tighter key spacing
                    className={`flex justify-center gap-1 mx-auto`}
                >
                    {row.map(key => (
                        <button
                            key={key}
                            onClick={() => handleKeyClick(key)}
                            // FIX: Added max-w for better spacing consistency
                            className={`${baseKeyClass} ${enabledKeyClass} flex-1 min-w-[30px] max-w-[40px]`}
                        >
                            {key}
                        </button>
                    ))}
                </div>
            ))}
        </div>
    );
};
        // --- End Virtual Keyboard Component ---


        // --- Main Render Logic ---
        
        const renderGameContent = () => {
            if (status === GAME_STATUS.PLAYING || status === GAME_STATUS.WON) {
                
                const isUndoDisabled = currentPath.length <= 1 || loading;
                
                return (
                    <div className="flex flex-col space-y-4 w-full h-full items-center">
                        
                        {/* 1. HEADER-LIKE STATS BAR (Matches image_37c99f.png) */}
                        <div className="w-full max-w-md flex justify-between items-center text-lg font-extrabold text-gray-200 border-b-2 border-gray-700 pb-3 mb-4">
                            <div className="text-center">
                                <span className="text-sm text-purple-400 block font-normal">Start:</span>
                                <span className="font-mono-game uppercase text-purple-400">{startWord}</span>
                            </div>
                            <div className="text-center">
                                <span className="text-sm text-gray-400 block font-normal">Steps:</span>
                                <span className="font-mono-game text-yellow-400">{currentPath.length - 1}</span>
                            </div>
                            <div className="text-center">
                                <span className="text-sm text-green-400 block font-normal">Goal:</span>
                                <span className="font-mono-game uppercase text-green-400">{targetWord}</span>
                            </div>
                        </div>

                        {/* Message Display */}
                        <div className="w-full max-w-lg mb-6">
                            {/* IF EDITING: Show the specific instructional message with a red background and Zap icon. */}
                            {editingIndex !== null && status === GAME_STATUS.PLAYING ? (
                                <div className="py-2 px-4 bg-blue-600 text-white font-semibold rounded-xl shadow-lg flex items-center text-left">
                                    <Icons.Zap size={20} className="mr-2" /> {message}
                                </div>
                            ) : (
                                <MessageDisplay />
                            )}
                        </div>
                        
                        {/* 2. ACTIVE WORD TILES */}
                        {currentPath.length > 0 && <WordPathDisplay />}
                        
                        {/* 3. CONTROL BUTTONS (Matches image_37c99f.png style) */}
                        <div className="flex flex-col sm:flex-row gap-4 w-full max-w-sm mt-8">
                            {/* Quit Button */}
                            <button
                                onClick={quitGame}
                                className="flex-1 py-2 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-xl shadow-lg transition-colors flex items-center justify-center disabled:opacity-50"
                                disabled={loading}
                            >
                                <Icons.LogOut size={20} className="mr-2" /> Quit Game
                            </button>

                            {/* Undo Button - styled to match Submit button's prominence from the image, 
                                but repurposed for Undo since we don't have a separate Submit. */}
                            <button
                                onClick={undoLastMove}
                                className="flex-1 py-2 bg-green-700 hover:bg-green-600 text-white font-bold rounded-xl shadow-lg transition-colors flex items-center justify-center disabled:opacity-50"
                                disabled={isUndoDisabled}
                                title={isUndoDisabled ? "Cannot undo the starting word" : "Undo the last move"}
                            >
                                <Icons.RotateCcw size={20} className="mr-2" /> Undo Last
                            </button>
                        </div>

                        {/* 4. VIRTUAL KEYBOARD - Always shown when playing */}
                        <div className="w-full mt-6">
                            <VirtualKeyboard />
                        </div>
                    </div>
                );
            }

            // Status is MENU or SETUP (FIXED: Removed the duplicate "Select Level" h2 tag)
            return (
                <div className="flex flex-col items-center space-y-8 w-full">
                    {/* The LevelSelector component already contains the "Select Level" heading. */}
                    <LevelSelector />
                </div>
            );
        };
        
        return (
            <div className="min-h-screen bg-gray-900 text-white p-4 sm:p-8 flex justify-center items-start pt-10">
                <div className="w-full max-w-4xl space-y-8">
                    {/* Title and Header - SUBTITLE REMOVED WHEN PLAYING/WON */}
                    <header className="text-center space-y-2 mb-12">
                        <h1 className="text-4xl font-extrabold tracking-wide text-gray-200">
                            The <span className="text-teal-400">Word</span><br className="sm:hidden" /> Ladder Game
                        </h1>
                        {/* The subtitle is now only shown in the initial menu/setup screen. */}
                        {(status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP) && (
                            <p className="text-lg text-gray-400 italic">
                                Solve the word puzzle by changing one letter at a time!
                            </p>
                        )}
                    </header>
                    
                    {/* Message is shown above the LevelSelector if status is MENU/SETUP and an error exists */}
                    {(status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP) && message && <MessageDisplay />}
                    
                    {renderGameContent()}
                    
                    {showSettings && (
                        <SettingsModal 
                            onClose={() => setShowSettings(false)} 
                            allowCurseWords={allowCurseWords}
                            setAllowCurseWords={setAllowCurseWords}
                        />
                    )}

                    {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
                    
                    {status === GAME_STATUS.WON && (
                        <WinModal 
                            chain={currentPath}
                            steps={currentPath.length - 1}
                            onNewGame={quitGame}
                            onReplay={() => resetGame(startWord, targetWord, wordLength, false)}
                            startWord={startWord}
                            targetWord={targetWord}
                        />
                    )}
                </div>
            </div>
        );
    };

    // Render the React component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

</body>
</html>