<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Word Ladder Game - Levels</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Use Inter and Space Mono for a clean, modern, and code-like look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom font for words to give it a game feel */
        .font-mono-game {
            font-family: 'Space Mono', monospace;
        }
    </style>
</head>
<body class="bg-gray-900">

<div id="root">
    </div>

<script type="text/babel">
    const { useState, useCallback, useEffect, useMemo, useRef } = window.React; 
    const ReactDOM = window.ReactDOM;

    // --- ICON Definitions ---
    const Icons = {
		RefreshCw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4"/></svg>,        CheckCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><path d="M9 11l3 3L22 4"/></svg>,
        XCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6"/><path d="M9 9l6 6"/></svg>,
        ChevronRight: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18l6-6-6-6"/></svg>,
        Hash: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="4" y1="9" x2="20" y2="9"/><line x1="4" y1="15" x2="20" y2="15"/><line x1="10" y1="3" x2="8" y2="21"/><line x1="16" y1="3" x2="14" y2="21"/></svg>,
        BookOpen: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
        Loader: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a10 10 0 1 0 5.4 18.5"/><path d="M12 2v2"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M17.4 6.6l-1.4 1.4"/><path d="M6.6 17.4l-1.4 1.4"/></svg>,
        Zap: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
		Trophy: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 13c0 2.038-2.239 4.5-5 4.5S7 15.038 7 13c0 1.444 10 1.444 10 0Z"/><path fill="currentColor" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"/></svg>,        LogOut: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
		RotateCcw: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 9h13a5 5 0 0 1 0 10H7M3 9l4-4M3 9l4 4"/></svg>,        HelpCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>,
		Settings: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" strokeLinecap="square" strokeLinejoin="round" strokeWidth="2" d="M10 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h2m10 1a3 3 0 0 1-3 3m3-3a3 3 0 0 0-3-3m3 3h1m-4 3a3 3 0 0 1-3-3m3 3v1m-3-4a3 3 0 0 1 3-3m-3 3h-1m4-3v-1m-2.121 1.879-.707-.707m5.656 5.656-.707-.707m-4.242 0-.707.707m5.656-5.656-.707.707M12 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/></svg>,
		};

    // --- LEVEL CONFIGURATION ---
    const LEVELS = {
        EASY: { 
            name: '3-Letter Warmup', 
            description: 'Quick puzzles with small words.',
            length: 3, 
            pairs: [
                { start: 'cat', target: 'dog' },
                { start: 'pig', target: 'pen' },
                { start: 'sun', target: 'day' },
                { start: 'run', target: 'kid' },
                { start: 'try', target: 'buy' },
                { start: 'top', target: 'can' },
                { start: 'why', target: 'how' },
                { start: 'low', target: 'new' },
                { start: 'fix', target: 'met' },
                { start: 'red', target: 'dad' }
            ]
        },
        MEDIUM: { 
            name: '4-Letter Standard', 
            description: 'The classic Word Chain experience.',
            length: 4, 
            pairs: [
                { start: 'cool', target: 'book' },
                { start: 'word', target: 'game' },
                { start: 'make', target: 'lake' },
                { start: 'slow', target: 'fast' },
                { start: 'lead', target: 'gold' },
                { start: 'home', target: 'cave' },
                { start: 'ship', target: 'boat' },
                { start: 'four', target: 'five' },
                { start: 'mind', target: 'move' },
                { start: 'fall', target: 'rise' }
            ]
        },
        HARD: { 
            name: '5-Letter Challenge', 
            description: 'Longer words requiring careful thought.',
            length: 5, 
            pairs: [
                { start: 'drive', target: 'dream' },
                { start: 'plane', target: 'glass' },
                { start: 'crane', target: 'stack' },
                { start: 'light', target: 'heavy' },
                { start: 'wheat', target: 'bread' },
                { start: 'smart', target: 'dummy' },
                { start: 'solve', target: 'proof' },
                { start: 'stone', target: 'money' },
                { start: 'train', target: 'wheel' },
                { start: 'heart', target: 'break' }
            ]
        }
    };

    // --- BASIC HARDCODED PROFANITY LIST for demonstration ---
    const PROFANITY_LIST = [
        'shit', 'fuck', 'ass', 'bitch', 'cunt', 'piss', 'nigga', 'boob',
        'wank', 'dick', 'crap', 'pube', 'slut', 'tits', 'cock', 'boobs'
    ];

    // Dictionary API for word validation
    const API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';
    const MAX_RETRIES = 3;
	
	// Whitelist for common, short words that the live API might occasionally fail to find.
    const LOCAL_WORD_WHITELIST = [
        'look', 'good', 'door', 'fish', 'four', 'five', 'tree', 'zero', 'jump', 'move', 'hold', 'send'
    ];

    /**
     * Checks word validity using the Dictionary API and an internal profanity filter.
     */
    const checkWordValidity = async (word, allowCurseWords, retries = 0) => {
        const cleanedWord = word.trim().toLowerCase();
        if (cleanedWord === '') return false;

        // --- PROFANITY CHECK ---
        if (!allowCurseWords) {
            if (PROFANITY_LIST.includes(cleanedWord)) {
                return false; 
            }
        }
        // --- END PROFANITY CHECK ---
		
        // NEW LOCAL CHECK: Bypass API if word is in the local whitelist
        if (LOCAL_WORD_WHITELIST.includes(cleanedWord)) {
            return true;
        }
        const url = `${API_URL}${cleanedWord}`;
        
        try {
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                return Array.isArray(data);
            } else if (response.status === 404) {
                return false;
            } else {
                throw new Error(`API returned status ${response.status}`);
            }
        } catch (error) {
            if (retries < MAX_RETRIES) {
                const delay = Math.pow(2, retries) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
                return checkWordValidity(word, allowCurseWords, retries + 1); 
            }
            console.error(`Failed to check word validity for "${word}" after ${MAX_RETRIES} retries:`, error);
            return false; 
        }
    };

    /**
     * Checks if the current word is exactly one letter different from the previous word.
     */
    const isOneLetterDifference = (prevWord, currentWord) => {
        if (prevWord.length !== currentWord.length) return false;
        let diffCount = 0;
        for (let i = 0; i < prevWord.length; i++) {
            if (prevWord[i] !== currentWord[i]) {
                diffCount++;
            }
        }
        return diffCount === 1;
    };

    // --- HELP MODAL COMPONENT ---
    const HelpModal = ({ onClose }) => { /* (omitted for brevity, assume contents are unchanged) */ return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
                <div 
                    className="w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6 transform transition-all"
                    onClick={(e) => e.stopPropagation()} 
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-3">
                        <h2 className="text-3xl font-extrabold text-purple-400 flex items-center">
                            <Icons.HelpCircle className="mr-3" size={30} /> How to Play
                        </h2>
                        <button onClick={onClose} className="p-2 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={28} />
                        </button>
                    </div>

                    <div className="space-y-6">
                        {[
                            {
                                title: "The Goal",
                                text: "The objective is to change the starting word into the target word, one step at a time.",
                            },
                            {
                                title: "The Rules (Crucial!)",
                                text: "In each step (or link in the chain), you must create a new word by changing only one letter from the previous word. All words must be valid English words.",
                                example: "Example: CAT â†’ COT (change 'A' to 'O') â†’ COG (change 'T' to 'G')."
                            },
                            {
                                title: "How to Play a Turn (Cross-Device)",
                                text: "1. Click/tap on any letter in the current (bottom-most) word in your chain.\n2. For **Mobile**, the keyboard will appear. Type the new letter.\n3. For **Desktop**, the cursor is hidden, just type the new letter immediately.\n4. The game will automatically check and submit the new word.",
                            },
                            {
                                title: "Winning",
                                text: "You win the game when you successfully create the **Target Word**. The fewest steps wins!",
                            }
                        ].map((step, index) => (
                            <div key={index} className="p-4 bg-gray-700/50 rounded-lg border-l-4 border-purple-500 shadow-md">
                                <h3 className="text-xl font-bold text-gray-100 mb-2">{index + 1}. {step.title}</h3>
                                <p className="text-gray-300 whitespace-pre-wrap">{step.text}</p>
                                {step.example && (
                                    <p className="mt-2 p-2 bg-gray-800 rounded text-yellow-400 font-mono-game text-lg border border-yellow-500/50">
                                        {step.example}
                                    </p>
                                )}
                            </div>
                        ))}
                    </div>

                    <div className="pt-4 border-t border-gray-700">
                        <button
                            onClick={onClose}
                            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200"
                        >
                            Got It, Let's Play!
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- NEW: SETTINGS MODAL COMPONENT ---
    const SettingsModal = ({ onClose, allowCurseWords, setAllowCurseWords }) => { /* (omitted for brevity, assume contents are unchanged) */ return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
                <div 
                    className="w-full max-w-md max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6 transform transition-all"
                    onClick={(e) => e.stopPropagation()} // Prevent closing
                >
                    <div className="flex justify-between items-center border-b border-purple-500/50 pb-3">
                        <h2 className="text-3xl font-extrabold text-purple-400 flex items-center">
                            <Icons.Settings className="mr-3" size={30} /> Game Settings
                        </h2>
                        <button onClick={onClose} className="p-2 text-gray-400 hover:text-white transition-colors">
                            <Icons.XCircle size={28} />
                        </button>
                    </div>

                    <div className="space-y-4">
                        <div className="flex justify-between items-center p-4 bg-gray-700/50 rounded-lg border-l-4 border-blue-500 shadow-md">
                            <div>
                                <h3 className="text-xl font-bold text-gray-100">Allow Profanity</h3>
                                <p className="text-sm text-gray-300">Allow potentially offensive or sensitive words.</p>
                            </div>
                            {/* Toggle Switch */}
                            <button
                                onClick={() => setAllowCurseWords(prev => !prev)}
                                className={`relative inline-flex items-center h-8 w-14 rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 ${allowCurseWords ? 'bg-green-600' : 'bg-gray-600'}`}
                            >
                                <span className="sr-only">Toggle Profanity Filter</span>
                                <span
                                    className={`inline-block w-6 h-6 transform bg-white rounded-full transition-transform ${allowCurseWords ? 'translate-x-6' : 'translate-x-1'}`}
                                ></span>
                            </button>
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700">
                        <button
                            onClick={onClose}
                            className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200"
                        >
                            Close Settings
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- WIN MODAL COMPONENT (NEW) ---
    const WinModal = ({ chain, steps, onNewGame, onReplay, startWord, targetWord }) => { /* (omitted for brevity, assume contents are unchanged) */ return (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-80 backdrop-blur-sm">
                <div 
                    className="w-full max-w-4xl max-h-[90vh] overflow-y-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-10 space-y-6 transform transition-all border-4 border-green-500"
                >
                    <div className="text-center space-y-4">
                        <Icons.Trophy className="mx-auto text-yellow-400" size={60} />
                        <h2 className="text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-teal-500">
                            CONGRATULATIONS!
                        </h2>
                        <p className="text-2xl font-semibold text-gray-200">
                            You solved the chain in <span className="text-yellow-400">{steps}</span> steps!
                        </p>
                    </div>

                    <div className="space-y-3">
                        <h3 className="text-xl font-bold text-gray-300 border-b border-gray-700 pb-2">Your Winning Chain:</h3>
                        {/* Horizontal display of the full word chain - ONLY SHOWN HERE */}
                        <div className="flex flex-wrap justify-center gap-2 max-h-[200px] overflow-y-auto p-2 border border-gray-700 rounded-lg bg-gray-900/50">
                            {chain.map((word, index) => (
                                <div 
                                    key={index}
                                    className={`px-4 py-2 rounded-lg font-mono-game text-xl font-bold uppercase transition-all duration-300 shadow-md
                                        ${word === startWord ? 'bg-purple-600 text-white' :
                                          word === targetWord ? 'bg-green-600 text-white' :
                                          'bg-gray-600 text-white'
                                        }`}
                                >
                                    {word}
                                    {/* Arrow separator (skip after the last word) */}
                                    {index < chain.length - 1 && (
                                        <span className="ml-2 text-gray-400">â†’</span>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="pt-4 border-t border-gray-700 flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        {/* New Game Button */}
                        <button
                            onClick={onNewGame}
                            className="flex-1 px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.BookOpen size={20} className="mr-2" /> New Game
                        </button>
                        
                        {/* Replay Button */}
                        <button
                            onClick={onReplay}
                            className="flex-1 px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-extrabold rounded-full shadow-lg transition-transform duration-300 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center"
                        >
                            <Icons.RefreshCw size={20} className="mr-2" /> Replay
                        </button>
                    </div>
                </div>
            </div>
        );
    };

    // --- MAIN APP COMPONENT ---

    const App = () => {
        const [startWord, setStartWord] = useState('');
        const [targetWord, setTargetWord] = useState('');
        const [wordLength, setWordLength] = useState(0);
        const [currentPath, setCurrentPath] = useState([]); // Array of words in the chain
        const [status, setStatus] = useState('MENU'); // MENU, PLAYING, WON, SETUP
        const [message, setMessage] = useState('');
        const [loading, setLoading] = useState(false);
        
        const [showHelp, setShowHelp] = useState(false); 
        const [showSettings, setShowSettings] = useState(false);
        const [allowCurseWords, setAllowCurseWords] = useState(false); 

        const [editingIndex, setEditingIndex] = useState(null); // Index of the letter being edited
        const [currentEditWord, setCurrentEditWord] = useState(''); // The word being typed/previewed before submission
        
        // Ref for the hidden input field (Mobile Keyboard Fix)
        const inputRef = useRef(null); 

        // Memoize the last word in the successful chain
        const lastWord = useMemo(() => currentPath[currentPath.length - 1], [currentPath]);

        // Update the word being edited whenever the last successful word changes
        useEffect(() => {
            setCurrentEditWord(lastWord || '');
        }, [lastWord]);

        const GAME_STATUS = {
            MENU: 'MENU',
            PLAYING: 'PLAYING',
            WON: 'WON',
            SETUP: 'SETUP' 
        };

        const submitWord = useCallback(async (submittedWord) => {
            setMessage('');
            setLoading(true);

            // 1. Check for length/format
            if (submittedWord.length !== wordLength) {
                setMessage(`Word must be exactly ${wordLength} letters long.`);
                setLoading(false);
                setCurrentEditWord(lastWord);
                return;
            }

            // Rule 2: Must be one letter different
            if (!isOneLetterDifference(lastWord, submittedWord)) {
                setMessage(`The new word "${submittedWord.toUpperCase()}" must differ by only one letter from "${lastWord.toUpperCase()}".`);
                setLoading(false);
                setCurrentEditWord(lastWord); 
                return;
            }
            
            // Rule 3: Cannot be an old word in the path
            if (currentPath.includes(submittedWord)) {
                setMessage(`"${submittedWord.toUpperCase()}" is already in your chain. Try a new word.`);
                setLoading(false);
                setCurrentEditWord(lastWord); 
                return;
            }
            
            // API Check (includes profanity check)
            setMessage(`Checking "${submittedWord.toUpperCase()}" in the live dictionary...`);
            const isValid = await checkWordValidity(submittedWord, allowCurseWords);
            setLoading(false);
            
            if (!isValid) {
                let failMessage = `"${submittedWord.toUpperCase()}" is not recognized as a valid word. Try again.`;
                if (!allowCurseWords && PROFANITY_LIST.includes(submittedWord)) {
                    failMessage = `Profanity not allowed.`; 
                }
                setMessage(failMessage);
                setCurrentEditWord(lastWord); 
                return;
            }

            // Valid move
            const newPath = [...currentPath, submittedWord];
            setCurrentPath(newPath);
            
            if (submittedWord === targetWord) {
                setMessage(`ðŸŽ‰ CONGRATULATIONS! You solved the chain in ${newPath.length - 1} steps!`);
                setStatus(GAME_STATUS.WON);
                // Blur the input to hide the keyboard on win
                if (inputRef.current) inputRef.current.blur();
            } else {
                setMessage('Excellent move! Keep going, one letter at a time.');
            }
            
        }, [lastWord, currentPath, targetWord, wordLength, allowCurseWords]); 


        /**
         * Unified game start/reset function
         */
        const resetGame = useCallback(async (start, target, length, isCustom = false) => {
            const s = start.toLowerCase().trim();
            const t = target.toLowerCase().trim();
            
            setEditingIndex(null);
            setMessage('');
            if (inputRef.current) inputRef.current.blur(); // Hide keyboard on reset

            // --- Word Length Validation ---
            if (s.length !== length || t.length !== length || s.length === 0) {
                const source = isCustom ? 'custom setup' : 'level configuration';
                setMessage(`[Validation Error from ${source.toUpperCase()}]: Both words must be exactly ${length} letters long.`);
                setStatus(isCustom ? GAME_STATUS.SETUP : GAME_STATUS.MENU);
                return;
            }

            // --- Custom Level Specific Checks ---
            if (isCustom) {
                if (s === t) {
                    setMessage(`[Validation Error]: The Start Word and Target Word cannot be the same. Please choose different words.`);
                    setStatus(GAME_STATUS.SETUP);
                    return;
                }
                if (!/^[a-z]+$/.test(s) || !/^[a-z]+$/.test(t)) {
                    setMessage(`[Validation Error]: Words must only contain lowercase English letters (a-z) and no spaces.`);
                    setStatus(GAME_STATUS.SETUP);
                    return;
                }
            }


            setWordLength(length);
            
            setLoading(true);
            setMessage('Validating words via API...');

            let isStartValid = true;
            let isTargetValid = true;

            if (isCustom) {
                [isStartValid, isTargetValid] = await Promise.all([
                    checkWordValidity(s, allowCurseWords),
                    checkWordValidity(t, allowCurseWords)
                ]);
            }
            
            setLoading(false);

            // --- Dictionary Validation Feedback ---
            if (!isStartValid || !isTargetValid) {
                let errorMsg = `[Dictionary Error]: `;
                
                let isStartProfane = !allowCurseWords && PROFANITY_LIST.includes(s);
                let isTargetProfane = !allowCurseWords && PROFANITY_LIST.includes(t);

                if (isStartProfane || isTargetProfane) {
                    errorMsg = `[Profanity Block]: Profanity not allowed.`; 
                } else {
                    if (!isStartValid && !isTargetValid) {
                        errorMsg += `Neither "${s.toUpperCase()}" nor "${t.toUpperCase()}" are valid words.`;
                    } else if (!isStartValid) {
                        errorMsg += `The Start Word "${s.toUpperCase()}" is not a valid English word.`;
                    } else {
                        errorMsg += `The Target Word "${t.toUpperCase()}" is not a valid English word.`;
                    }
                }
                
                setMessage(errorMsg);
                setStatus(GAME_STATUS.SETUP); 
                return;
            }

            // Success
            setStartWord(s);
            setTargetWord(t);
            setCurrentPath([s]);
            setCurrentEditWord(s);
            setMessage(`Start your chain! Change a letter in ${s.toUpperCase()} by clicking it.`);
            setStatus(GAME_STATUS.PLAYING);
        }, [allowCurseWords]); 

        const startLevel = (levelKey) => {
            const level = LEVELS[levelKey];
            const pair = level.pairs[Math.floor(Math.random() * level.pairs.length)];
            resetGame(pair.start, pair.target, level.length, false);
        };
        
        const quitGame = () => {
            setStartWord('');
            setTargetWord('');
            setWordLength(0);
            setCurrentPath([]);
            setMessage('');
            setEditingIndex(null);
            setCurrentEditWord('');
            setStatus(GAME_STATUS.MENU);
            if (inputRef.current) inputRef.current.blur(); // Hide keyboard on quit
        };

        // --- Undo Last Move Function ---
        const undoLastMove = useCallback(() => {
            if (currentPath.length > 1 && status === GAME_STATUS.PLAYING && !loading) {
                const newPath = currentPath.slice(0, -1); 
                const newLastWord = newPath[newPath.length - 1];
                
                setCurrentPath(newPath);
                setCurrentEditWord(newLastWord);
                setEditingIndex(null); 
                setMessage(`Move undone. Current word is ${newLastWord.toUpperCase()}.`);
                if (inputRef.current) inputRef.current.blur(); // Hide keyboard on undo
            }
        }, [currentPath, status, loading]);

        // --- Keyboard and Letter Click Logic ---

        const handleLetterClick = useCallback((index) => {
            if (status !== GAME_STATUS.PLAYING || loading) return;

            if (editingIndex === index) {
                // Clicking the already active letter cancels editing
                setEditingIndex(null);
                setMessage('');
                setCurrentEditWord(lastWord);
                if (inputRef.current) inputRef.current.blur(); // Blur to hide keyboard
            } else {
                // Start editing a new letter
                setEditingIndex(index);
                setMessage(`Type the new letter for position ${index + 1}. Press ESC to cancel.`);
                
                // Programmatically focus the hidden input field (brings up mobile virtual keyboard)
                if (inputRef.current) {
                    inputRef.current.focus(); 
                }
            }
        }, [status, loading, editingIndex, lastWord]);
        
        // ----------------------------------------------------------------------
        // FIX FOR DESKTOP KEYBOARD INPUT (Re-introducing Global Listener)
        // ----------------------------------------------------------------------

        // Global Keypress Handler (For Desktop/Physical Keyboards)
        const handleKeyPress = useCallback((event) => {
            // Only process input if game is playing and a letter is selected
            if (status !== GAME_STATUS.PLAYING || loading || editingIndex === null) {
                // Allow ESC key to still work even if a letter isn't selected
                if (event.key.toLowerCase() === 'escape') {
                    setEditingIndex(null);
                    setMessage('Editing canceled.');
                    setCurrentEditWord(lastWord);
                    if (inputRef.current) inputRef.current.blur();
                }
                return; 
            }

            const key = event.key.toLowerCase();
            
            // 1. Handle non-letter keys
            if (key.length > 1) {
                if (key === 'escape') {
                    event.preventDefault();
                    setEditingIndex(null);
                    setMessage('Editing canceled.');
                    setCurrentEditWord(lastWord);
                    if (inputRef.current) inputRef.current.blur();
                }
                // Allow backspace/delete on the input itself if it's focused, but ignore for the game logic
                return; 
            }

            // 2. Handle letter input (Physical Keyboard)
            if (key.length === 1 && /^[a-z]$/.test(key)) {
                event.preventDefault(); // Stop the key from potentially interfering with the hidden input's state
                
                const newWordArr = lastWord.split('');
                
                // Check if the user is typing the same letter at the same spot (no change)
                if (newWordArr[editingIndex] === key) {
                     setMessage(`The letter is already '${key.toUpperCase()}' at this position. Choose a new letter.`);
                     return;
                }

                // Create the potential new word
                newWordArr[editingIndex] = key;
                const potentialWord = newWordArr.join('');
                
                // Submit the word directly for full validation
                submitWord(potentialWord); 
                
                // After submission attempt, clear the editing index and hide the keyboard
                setEditingIndex(null); 
                if (inputRef.current) inputRef.current.blur(); 
            }

        }, [status, loading, editingIndex, lastWord, submitWord]); 

        // Re-introduce the global useEffect listener (Desktop Fix)
        useEffect(() => {
            window.addEventListener('keydown', handleKeyPress);
            return () => {
                window.removeEventListener('keydown', handleKeyPress);
            };
        }, [handleKeyPress]);

        // ----------------------------------------------------------------------
        // MOBILE KEYBOARD INPUT (Handling Input's onChange)
        // ----------------------------------------------------------------------
        
        // Change handler for letter input (Virtual Keyboard Fix)
        const handleInputChange = useCallback((event) => {
            const potentialWord = event.target.value.toLowerCase().trim();
            
            // Should only be active if a letter is selected for editing
            if (editingIndex === null) {
                // If the user somehow typed without a selection, revert the input to the last word
                setCurrentEditWord(lastWord); 
                inputRef.current.focus(); 
                return;
            }

            // 1. Check if the length is correct and the word is different
            if (potentialWord.length === wordLength && potentialWord !== lastWord) {
                
                // 2. Check if it's only one letter different (Crucial for virtual keyboard validation)
                if (isOneLetterDifference(lastWord, potentialWord)) {
                    
                    // Submit the word for full validation
                    submitWord(potentialWord);
                    
                    // Clear the editing focus
                    setEditingIndex(null);
                    
                } else {
                    // Invalid single change (e.g. backspace, or two letters typed quickly)
                    setMessage("Invalid input: only one letter difference allowed.");
                    setCurrentEditWord(lastWord); // Revert back to last word
                    inputRef.current.focus(); // Keep focus for another attempt
                }
                
            } else {
                // Invalid length or same word (e.g. they typed the same letter or backspaced)
                if (potentialWord.length < wordLength) {
                     setMessage(`Word must be exactly ${wordLength} letters long.`);
                }
                setCurrentEditWord(lastWord); // Revert to last word
                inputRef.current.focus(); // Maintain focus
            }

        }, [editingIndex, lastWord, wordLength, submitWord]);


        // --- UI COMPONENTS ---
        // (MessageDisplay, LevelSelector, CustomWordSetup, WordTile, WordPathDisplay components omitted for brevity, assume contents are unchanged)
        
        const MessageDisplay = () => {
            let currentMessage = message;
            let icon = null;
            let colorClass = 'bg-blue-600';
            let iconSize = 20;

            if (!currentMessage && !loading) return null;

            // Check for explicit error markers added in validation logic
            const isError = currentMessage.includes('[Validation Error]') || currentMessage.includes('[Dictionary Error]') || currentMessage.includes('[Profanity Block]') || currentMessage.includes('differ by only one') || currentMessage.includes('already in your chain') || currentMessage.includes('Invalid input');

            if (loading) {
                currentMessage = message || '...connecting to dictionary...';
                icon = <Icons.Loader size={iconSize} className="animate-spin" />;
                colorClass = 'bg-yellow-600';
            } else if (status === GAME_STATUS.WON) {
                icon = <Icons.Trophy size={iconSize} />;
                colorClass = 'bg-green-600';
            } else if (isError) {
                icon = <Icons.XCircle size={iconSize} />;
                colorClass = 'bg-red-600';
            } else if (status === GAME_STATUS.PLAYING) {
                icon = <Icons.CheckCircle size={iconSize} />;
                colorClass = 'bg-blue-600';
            }


            return (
                <div className={`p-4 rounded-xl shadow-2xl text-white font-semibold flex items-center space-x-3 ${colorClass}`}>
                    {icon}
                    <span>{currentMessage}</span>
                </div>
            );
        };

        const LevelSelector = () => (
            <div className="space-y-6">
                
                <div className="flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
                    <h2 className="text-3xl font-bold text-gray-100 flex items-center">
                        <Icons.Zap className="mr-3 text-yellow-400" size={28} /> Select Difficulty Level
                    </h2>
                    
                    <div className="flex space-x-4">
                        <button
                            onClick={() => setShowSettings(true)}
                            className="py-2 px-4 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.Settings size={20} className="mr-2" /> Settings
                        </button>
                        
                        <button
                            onClick={() => setShowHelp(true)}
                            className="py-2 px-4 bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-full shadow-lg transition-transform duration-200 transform hover:scale-[1.05] active:scale-95 flex items-center justify-center disabled:opacity-50"
                            disabled={loading}
                        >
                            <Icons.HelpCircle size={20} className="mr-2" /> How to Play
                        </button>
                    </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    {Object.keys(LEVELS).map(key => {
                        const level = LEVELS[key];
                        const color = key === 'EASY' ? 'bg-green-600 hover:bg-green-700' :
                                      key === 'MEDIUM' ? 'bg-blue-600 hover:bg-blue-700' :
                                      'bg-red-600 hover:bg-red-700';

                        return (
                            <button
                                key={key}
                                onClick={() => startLevel(key)}
                                disabled={loading}
                                className={`p-6 rounded-xl text-white font-extrabold shadow-xl transition-all duration-300 transform hover:scale-[1.05] disabled:opacity-50 ${color}`}
                            >
                                <div className="text-2xl mb-1">{level.name}</div>
                                <div className="text-sm opacity-80 mb-2">{level.description}</div>
                                <div className="text-xs italic">({level.length} letters)</div>
                            </button>
                        );
                    })}
                </div>
                
                <CustomWordSetup />
            </div>
        );

        const CustomWordSetup = () => {
            const initialLength = 4;
            const [customStart, setCustomStart] = useState('word'); 
            const [customTarget, setCustomTarget] = useState('game');
            const [customLength, setCustomLength] = useState(initialLength);
            const [showInput, setShowInput] = useState(status === GAME_STATUS.SETUP);
            
            const lengthOptions = Object.values(LEVELS).map(l => l.length);
            if (!lengthOptions.includes(6)) lengthOptions.push(6);
            lengthOptions.sort((a, b) => a - b); 

            useEffect(() => {
                const s = customStart.toLowerCase().trim().slice(0, customLength);
                const t = customTarget.toLowerCase().trim().slice(0, customLength);
                setCustomStart(s);
                setCustomTarget(t);
            }, [customLength]);

            useEffect(() => {
                if (status === GAME_STATUS.SETUP) {
                    setShowInput(true);
                }
            }, [status]);


            const handleCustomStart = () => {
                resetGame(customStart, customTarget, customLength, true);
            };

            const isButtonDisabled = customStart.length !== customLength || 
                                     customTarget.length !== customLength ||
                                     customStart.trim() === '' ||
                                     customTarget.trim() === '' ||
                                     customStart.toLowerCase() === customTarget.toLowerCase() ||
                                     loading;


            return (
                <div className="p-6 bg-gray-700/60 rounded-xl shadow-2xl space-y-4 backdrop-blur-md border border-purple-500/50">
                    <button 
                        onClick={() => setShowInput(!showInput)}
                        className="w-full text-left py-2 text-lg font-bold text-purple-300 flex items-center justify-between"
                    >
                        Custom Level Setup
                        <Icons.ChevronRight className={`transition-transform duration-300 ${showInput ? 'rotate-90' : ''}`} />
                    </button>
                    
                    {showInput && (
                        <div className="space-y-4 pt-2">
                             <div className="flex items-center space-x-3">
                                <label className="text-gray-300 min-w-[100px] font-semibold">Word Length:</label>
                                <select 
                                    value={customLength} 
                                    onChange={(e) => {
                                        setCustomLength(parseInt(e.target.value));
                                        setMessage('');
                                    }}
                                    className="p-2 rounded-lg bg-gray-600 text-white focus:ring-2 focus:ring-purple-400 border border-transparent transition cursor-pointer"
                                >
                                    {lengthOptions.map(l => (
                                        <option key={l} value={l}>{l} Letters</option>
                                    ))}
                                </select>
                            </div>

                            <div className="flex flex-col sm:flex-row gap-4">
                                <input
                                    type="text"
                                    value={customStart.toUpperCase()} 
                                    onChange={(e) => setCustomStart(e.target.value.toLowerCase().replace(/[^a-z]/g, '').slice(0, customLength))}
                                    placeholder={`Start Word (${customLength} letters)`}
                                    className={`flex-1 p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 border transition font-mono-game uppercase 
                                        ${customStart.length === customLength ? 'border-green-400' : 'border-red-400'}`}
                                    maxLength={customLength}
                                />
                                <input
                                    type="text"
                                    value={customTarget.toUpperCase()}
                                    onChange={(e) => setCustomTarget(e.target.value.toLowerCase().replace(/[^a-z]/g, '').slice(0, customLength))}
                                    placeholder={`Target Word (${customLength} letters)`}
                                    className={`flex-1 p-3 rounded-lg bg-gray-600 text-white placeholder-gray-400 focus:ring-2 border transition font-mono-game uppercase
                                        ${customTarget.length === customLength ? 'border-green-400' : 'border-red-400'}`}
                                    maxLength={customLength}
                                />
                            </div>
                            <button
                                onClick={handleCustomStart}
                                className="w-full py-3 bg-purple-500 hover:bg-purple-600 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                disabled={isButtonDisabled}
                            >
                                <Icons.RefreshCw size={20} className="mr-2" /> Start Custom Level
                            </button>
                            {isButtonDisabled && !loading && (
                                <p className="text-sm text-red-400 text-center">
                                    Please ensure both words are exactly {customLength} letters long, contain only letters, and are different.
                                </p>
                            )}
                        </div>
                    )}
                </div>
            );
        };


        const WordTile = ({ word, pathIndex }) => {
            const isLastWord = pathIndex === currentPath.length - 1;
            const isStartWord = pathIndex === 0;
            const isTargetWord = word === targetWord;
            
            const displayWord = isLastWord ? currentEditWord : word;
            const letters = displayWord.split('');
            const isActive = isLastWord && status === GAME_STATUS.PLAYING && !loading;

            const baseColor = isStartWord 
                ? 'bg-purple-600/70 text-white' 
                : isTargetWord 
                    ? 'bg-green-600/70 text-white' 
                    : 'bg-gray-700/50 text-gray-200';

            if (!isActive) {
                return (
                    <div className={`p-3 rounded-xl shadow-lg font-mono-game text-xl uppercase transition-all duration-300 transform ${baseColor}`}>
                        {word}
                    </div>
                );
            }
            
            const letterSizeClass = wordLength === 3 ? 'w-12 h-12 text-4xl' : wordLength === 4 ? 'w-10 h-10 text-3xl' : wordLength === 5 ? 'w-8 h-8 text-2xl' : 'w-7 h-7 text-xl';

            return (
                <div
                    className={`flex justify-center items-center rounded-xl shadow-xl font-mono-game uppercase tracking-widest p-2 transition-all duration-300 
                        ${isActive ? 'bg-gray-700 ring-4 ring-yellow-500/80' : 'bg-gray-800'}`}
                >
                    {letters.map((char, charIndex) => (
                        <div
                            key={charIndex}
                            className={`flex items-center justify-center m-1 rounded-lg font-extrabold cursor-pointer transition-all duration-150 
                                ${letterSizeClass}
                                ${editingIndex === charIndex 
                                    ? 'bg-red-500 text-white shadow-inner ring-2 ring-red-300' // Editing state
                                    : (char !== lastWord[charIndex] 
                                        ? 'bg-blue-500 text-white hover:bg-blue-600 ring-2 ring-blue-300' // Changed letter preview
                                        : 'bg-gray-600/50 text-white hover:bg-gray-600' // Unchanged letter
                                    )
                                }`
                            }
                            onClick={() => isActive && handleLetterClick(charIndex)}
                        >
                            {char}
                            {/* Flashing cursor effect on active editing letter */}
                            {editingIndex === charIndex && <div className="absolute w-1 h-3 bg-white animate-pulse" style={{ animationDuration: '0.8s' }}></div>}
                        </div>
                    ))}
                </div>
            );
        };
        
        const WordPathDisplay = () => {
            const scrollRef = useRef(null); 

            useEffect(() => {
                if (scrollRef.current) {
                    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                }
            }, [currentPath]);

            return (
                <div className="p-6 bg-gray-800/80 rounded-xl shadow-inner space-y-4">
                    <h2 className="text-2xl font-bold text-gray-200">Your Chain</h2>
                    <div 
                        ref={scrollRef}
                        className="flex flex-col space-y-3 pr-2" 
                        style={{ maxHeight: '200px', overflowY: 'auto' }} 
                    >
                        {currentPath.map((word, index) => {
                            return (
                                <div key={index} className="flex items-center">
                                    <div className="min-w-10 text-center font-bold text-lg text-gray-400 pr-4">{index + 1}.</div>
                                    <div className="my-1">
                                        <WordTile word={word} pathIndex={index} />
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- Main Render Logic ---
        
        const renderGameContent = () => {
            if (status === GAME_STATUS.PLAYING || status === GAME_STATUS.WON) {
                
                const isUndoDisabled = currentPath.length <= 1 || loading;
                
                return (
                    <>
                        {/* Game Info and Action Panel */}
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            
                            {/* Stats Panel */}
                            <div className="p-6 bg-gray-800/60 rounded-xl shadow-2xl space-y-3 backdrop-blur-md lg:col-span-1 border border-gray-700">
                                <h3 className="text-xl font-bold text-gray-100 mb-3 border-b border-gray-600 pb-2">Game Stats</h3>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.BookOpen className="mr-2 text-green-400" size={18} /> Goal Word:</span>
                                    <span className="font-extrabold text-xl text-green-400 uppercase font-mono-game">{targetWord}</span>
                                </div>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.Hash className="mr-2 text-yellow-400" size={18} /> Steps Taken:</span>
                                    <span className="font-extrabold text-xl text-yellow-400 font-mono-game">{currentPath.length - 1}</span>
                                </div>
                                <div className="flex justify-between items-center text-gray-300">
                                    <span className="font-semibold flex items-center"><Icons.Zap className="mr-2 text-purple-400" size={18} /> Word Length:</span>
                                    <span className="font-extrabold text-xl text-purple-400 font-mono-game">{wordLength}</span>
                                </div>
                            </div>
                            
                            {/* Message Display and Control Buttons */}
                            <div className="lg:col-span-2 space-y-4">
                                <MessageDisplay />
                                
                                {(status === GAME_STATUS.PLAYING) && (
                                    <div className="flex flex-col sm:flex-row gap-4">
                                        {/* Undo Button */}
                                        <button
                                            onClick={undoLastMove}
                                            className="flex-1 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                            disabled={isUndoDisabled}
                                            title={isUndoDisabled ? "Cannot undo the starting word" : "Undo the last move"}
                                        >
                                            <Icons.RotateCcw size={20} className="mr-2" /> Undo Last Move
                                        </button>

                                        {/* Quit Button */}
                                        <button
                                            onClick={quitGame}
                                            className="flex-1 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition-transform duration-200 transform hover:scale-[1.02] active:scale-95 flex items-center justify-center disabled:opacity-50"
                                            disabled={loading}
                                        >
                                            <Icons.LogOut size={20} className="mr-2" /> Quit Game
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>


                        {/* Word Path Display (only show if path exists) */}
                        {currentPath.length > 0 && <WordPathDisplay />}
                    </>
                );
            }

            return <LevelSelector />;
        };
        
        return (
            <div className="min-h-screen bg-gray-900 text-white p-4 sm:p-8 flex justify-center items-start pt-10">
                <div className="w-full max-w-4xl space-y-8">
                    
                    {/* HIDDEN INPUT FIELD - Used ONLY to trigger the virtual keyboard on mobile */}
                    <input
                        ref={inputRef}
                        type="text"
                        value={currentEditWord.toUpperCase()} 
                        // Style it to be completely invisible and non-disruptive
                        className="opacity-0 absolute w-0 h-0 p-0 m-0 overflow-hidden" 
                        maxLength={wordLength}
                        autoCapitalize="off"
                        autoCorrect="off"
                        autoComplete="off"
                        // inputMode="text" and pattern="[a-zA-Z]*" are important for mobile keyboard behavior
                        inputMode="text" 
                        pattern="[a-zA-Z]*"
                        // Note: onKeyDown removed as it's handled by the global handleKeyPress now
                        onChange={handleInputChange}
                        disabled={editingIndex === null}
                    />

                    {/* Title and Header - NAME IS WORD CHAIN */}
                    <header className="text-center space-y-2 mb-8">
                        <h1 className="text-7xl font-extrabold tracking-wide text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
                            The Word Ladder Game
                        </h1>
                        <p className="text-lg text-gray-400 italic">
                            {status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP 
                                ? "Solve the word puzzle by changing one letter at a time!" 
                                : "Click a letter in the active word, then type a new letter to form the next valid word."
                            }
                        </p>
                    </header>
                    
                    {(status === GAME_STATUS.MENU || status === GAME_STATUS.SETUP) && message && <MessageDisplay />}
                    
                    {renderGameContent()}

                    {/* Settings Modal */}
                    {showSettings && (
                        <SettingsModal 
                            onClose={() => setShowSettings(false)} 
                            allowCurseWords={allowCurseWords}
                            setAllowCurseWords={setAllowCurseWords}
                        />
                    )}

                    {/* Help Modal */}
                    {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
                    
                    {/* Win Modal */}
                    {status === GAME_STATUS.WON && (
                        <WinModal 
                            chain={currentPath}
                            steps={currentPath.length - 1}
                            onNewGame={quitGame}
                            onReplay={() => resetGame(startWord, targetWord, wordLength, false)}
                            startWord={startWord}
                            targetWord={targetWord}
                        />
                    )}
                </div>
            </div>
        );
    };

    // Render the React component
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

</body>
</html>